---
title: "Eukaryote_subsection"
author: "Andreas Norlin"
date: "2023-10-13"
output: html_document
---

The initial code chunk (setup) is designed to clear the global environment, load the libraries needed for the code to run and to then load all the neccesary .csv.

Two meta data tables are loaded and merged together to get the HM (sample number) and the date and time for each sample. This data is also merged with the par data.

After the meta data is loaded, the subsectioned dataset is loaded and the temporal resolution of the par data is decreased to get a smaller sized data set for running the code quicker.

```{r setup, include=T}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2","lemon","vegan","Rmisc","lubridate")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)

#Loading the meta.data: meta.data1 is the Assmebly group and the sequencing ID (sample ID),
#meta.data2 is the data about sampling time and site.

meta.data1 <- read.csv("CSV_files/dielRNA_eukrythmic.tsv", sep = "\t")
meta.data2 <- read.csv("sample_metadata.csv") %>% 
  mutate(Sample_ID = paste("HM",Sample_ID,sep = ""))

names(meta.data2)[names(meta.data2) == "Sample_ID"] <- "SampleID"

#Combining meta.data1 and meta.data2 and making the lubri string a data + time saved in datetime
meta.data <- merge(meta.data1,meta.data2,by = "SampleID") %>% 
  mutate(datetime = ymd(substring(lubri,1,10))+hms(substring(lubri,12,19)))

meta.data <- separate(meta.data, col = AssemblyGroup, into = c("Day.num","ToD"),sep = "_",remove = FALSE, fill = "right", extra = "drop")

# meta.data$lubri <- with_tz(mdy_hms(meta.data$datetime, tz = "UTC"),
#                            tz = "America/Santiago")

COG_categories <- read.csv("CSV_files/COG_categories.csv",sep = ",")

Eukaryota.merged <- read.csv("CSV_files/Eukaryota.merged.csv")

par1 <- read.delim("NBP2113pguv.d342",  sep = " ", header =FALSE)
par2<- read.delim("NBP2113pguv.d343",  sep = " ", header =FALSE)
par3<- read.delim("NBP2113pguv.d344",  sep = " ", header =FALSE)

par = rbind(par1, par2, par3)[-1,c(1,2,3,10)]
names(par) <- c("juliendatetime","date", "time", "par")

partime <- par %>% 
  separate(juliendatetime, c("yearday","hour", "min", "sec"), sep = ":" ) %>% 
  unite(utctime, hour, min, sec, sep=":")  %>% 
  mutate(utcdatetime = paste(date, utctime))

partime$lubri <- with_tz(mdy_hms(partime$utcdatetime, tz = "UTC"),
                         tz = "America/Santiago")

for(i in 1:nrow(meta.data)){

  filter.above <- partime$lubri >= meta.data$datetime[i]
  filter.below <- partime$lubri < meta.data$datetime[i]
  
  vec.above <- partime[partime$lubri == min(partime$lubri[filter.above]),]
  vec.below <- partime[partime$lubri == max(partime$lubri[filter.below]),]
  
  meta.data$par[i] <- mean(vec.above$par,vec.below$par)
  
}

m <- 1
time.int <- ms("05.00")
for(i in 1:nrow(partime)){
  if(i == 1){
    vec <- NA
    vec.slide <- NA
    n <- 1
  }
  
  test.vec <- partime$lubri[i] - partime$lubri[m]
  
  if(test.vec > time.int){
    m <- i
    
    vec[n] <- i
    
    n <- n+1
  }
  
}

partime <- partime[vec,]
```


The second code chunk, subsections the full TPM and numread datasets to only include Eukaryotic read. This is run with the file: 'TaxonomicAndFunctionalAnnotations.csv' in the CSV_files folder.

The code also removes the .pxx from the Sequence ID.

```{r}
#Subsectioning the Eukaryota data from the Taxonomic and Functional Annotations file####

# tax.func <- read.csv("CSV_files/TaxonomicAndFunctionalAnnotations.csv", sep = "\t")
# 
# tax.func <- separate(tax.func,col = full_classification,into = c("Domain","Supergroup","Division","Class","Order","Family","Genus","Species"), sep = "; ", remove = FALSE, fill = "right", extra = "drop")
# 
# tax.func$Domain <- ifelse(substring(tax.func$Domain,1,1) == " ", substring(tax.func$Domain,2), tax.func$Domain)
# 
# Eukaryota <- tax.func[tax.func$Domain == "Eukaryota",]
# 
# Eukaryota$SequenceID <- ifelse(substring(Eukaryota$transcript_name, nchar(Eukaryota$transcript_name)-2, nchar(Eukaryota$transcript_name)-2) == ".",
#                               Eukaryota$SequenceID <- substring(Eukaryota$transcript_name,1,nchar(Eukaryota$transcript_name)-3),
#                               ifelse(substring(Eukaryota$transcript_name, nchar(Eukaryota$transcript_name)-3, nchar(Eukaryota$transcript_name)-3) == ".",
#                                      Eukaryota$SequenceID <- substring(Eukaryota$transcript_name,1,nchar(Eukaryota$transcript_name)-4),
#                                      Eukaryota$SequenceID <- Eukaryota$SequenceID))
# 
# write.csv(Eukaryota,"CSV_files/Eukaryota.subsection.TFA.csv", row.names = F)
```

The third code chunk filters the numread and TPM datasets to only include sequences that appear in the TaxonomicAndFunctionalAnnotations.csv file. This requires the files: 'Eukaryota.subsection.TFA.csv' (which is created in the code-chunk above), 'Eukaryota.subsection.numreads.csv' and 'salmon.merged.TPM.subset5.csv' to be present in the CSV_files folder.

```{r}
#Using the sequence ID's from the Eukaryota subsection to subsection the numreads and the TPM files####

# Eukaryota <- read.csv("CSV_files/Eukaryota.subsection.TFA.csv")
# 
# salmon.numread <- read.csv("CSV_files/salmon.merged.numreads.subset5.csv")
# filter <- salmon.numread$Name %in% Eukaryota$SequenceID
# 
# Eukaryota.numread <- salmon.numread[filter,]
# write.csv(Eukaryota.numread,"CSV_files/Eukaryota.subsection.numreads.csv",row.names = F)
# 
# salmon.TPM <- read.csv("CSV_files/salmon.merged.TPM.subset5.csv")
# filter <- salmon.TPM$Name %in% Eukaryota$SequenceID
# 
# Eukaryota.TPM <- salmon.TPM[filter,]
# write.csv(Eukaryota.TPM, "CSV_files/Eukaryota.subsection.TPM.csv",row.names = F)
```

The following code filters duplicate sequence IDs, multiple rows had the same sequence ID after the .pxx extension was removed. There is an emphasis on retaining as much data as possible, so the sequences are first filtered to include as many rows containing KEGG annotaions, and secondly rows are kept that contain COG annotations.

This code chunk is found in two versions, and the next code-chunk after this one is almost identical, the difference is that this code-chunk creates a final file that contains numread data, and the second chunk creates a file containing the TPM data.

This chunk needs the files: 'Eukaryota.subsection.numreads.csv' and 'Eukaryota.subsection.TFA.csv' to be present in the CSV_files folder.

```{r Numread merge}

#Raw read
# Eukaryota.numread <- read.csv("CSV_files/Eukaryota.subsection.numreads.csv")
# 
# Eukaryota.TFA <- read.csv("CSV_files/Eukaryota.subsection.TFA.csv")
# #Filtering out the sequences present in the Taxonomy and functional annotations data, but not in the numread/TPM
# filter <- Eukaryota.TFA$SequenceID %in% Eukaryota.numread$Name
# 
# Eukaryota.TFA <- Eukaryota.TFA[filter,]
# 
# #Seperates sequences with a KEGG from the sequences that don't
# filter <- Eukaryota.TFA$KEGG_ko != "-"
# 
# Eukaryota.KEGG <- Eukaryota.TFA[filter,]
# Eukaryota.noKEGG <- Eukaryota.TFA[!filter,]
# 
# #Creates a filter for the sequences that have KEGGs to seperate COGs and noCOGs
# filter1 <- Eukaryota.KEGG$COG_category == "-"
# 
# Eukaryota.KEGG.COG <- Eukaryota.KEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Eukaryota.KEGG.noCOG <- Eukaryota.KEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Eukaryota.KEGG.noCOG$SequenceID %in% Eukaryota.KEGG.COG$SequenceID
# 
# Eukaryota.KEGG <- rbind(Eukaryota.KEGG.COG,Eukaryota.KEGG.noCOG[!filter2,])
# 
# #Creates a filter for the sequences that doesn't have KEGGs to seperate COGs and noCOGs
# filter1 <- Eukaryota.noKEGG$COG_category == "-"
# 
# Eukaryota.noKEGG.COG <- Eukaryota.noKEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Eukaryota.noKEGG.noCOG <- Eukaryota.noKEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Eukaryota.noKEGG.noCOG$SequenceID %in% Eukaryota.noKEGG.COG$SequenceID
# 
# Eukaryota.noKEGG <- rbind(Eukaryota.noKEGG.COG,Eukaryota.noKEGG.noCOG[!filter2,])
# 
# #Filtering Sequences in noKEGG that are present in KEGG
# filter3 <- Eukaryota.noKEGG$SequenceID %in% Eukaryota.KEGG$SequenceID
# 
# Eukaryota.noRep <- rbind(Eukaryota.KEGG,Eukaryota.noKEGG[!filter3,])
# 
# write.csv(Eukaryota.noRep,"CSV_files/Eukaryota.TFA_NoRep.csv",row.names = F)
# 
# Eukaryota.noRep$Class <- ifelse(substring(Eukaryota.noRep$Class,nchar(Eukaryota.noRep$Class)-7) == " (Class)",
#                              substring(Eukaryota.noRep$Class,1,nchar(Eukaryota.noRep$Class)-8),
#                              Eukaryota.noRep$Class)
# 
# names(Eukaryota.numread)[1] <- "SequenceID"
# 
# df.merged <- merge(Eukaryota.numread,Eukaryota.noRep,by = "SequenceID")
# 
# df.merged$Class[is.na(df.merged$Class)] <- "Unclassified"
# 
# write.csv(df.merged,"CSV_files/Eukaryota.merged.csv",row.names = F)
```

This code chunk is the second version, and the previous code-chunk before this one is almost identical, the difference is that this code-chunk creates a final file that contains TPM data, and the second chunk creates a file containing the numread data.

This chunk needs the files: 'Eukaryota.subsection.TPM.csv' and 'Eukaryota.subsection.TFA.csv' to be present in the CSV_files folder.

Note that this chunk overwrites the file created in the previous chunk, this was done to minimize the stored .csv files needed.
```{r TPM merge}

#Transcripts per million
# Eukaryota.TPM <- read.csv("CSV_files/Eukaryota.subsection.TPM.csv")
# 
# Eukaryota.TFA <- read.csv("CSV_files/Eukaryota.subsection.TFA.csv")
# 
# #Filtering out the sequences present in the Taxonomy and functional annotations data, but not in the TPM
# filter <- Eukaryota.TFA$SequenceID %in% Eukaryota.TPM$Name
# 
# Eukaryota.TFA <- Eukaryota.TFA[filter,]
# 
# #Seperates sequences with a KEGG from the sequences that don't
# filter <- Eukaryota.TFA$KEGG_ko != "-"
# 
# Eukaryota.KEGG <- Eukaryota.TFA[filter,]
# Eukaryota.noKEGG <- Eukaryota.TFA[!filter,]
# 
# #Creates a filter for the sequences that have KEGGs to seperate COGs and noCOGs
# filter1 <- Eukaryota.KEGG$COG_category == "-"
# 
# Eukaryota.KEGG.COG <- Eukaryota.KEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Eukaryota.KEGG.noCOG <- Eukaryota.KEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Eukaryota.KEGG.noCOG$SequenceID %in% Eukaryota.KEGG.COG$SequenceID
# 
# Eukaryota.KEGG <- rbind(Eukaryota.KEGG.COG,Eukaryota.KEGG.noCOG[!filter2,])
# 
# #Creates a filter for the sequences that doesn't have KEGGs to seperate COGs and noCOGs
# filter1 <- Eukaryota.noKEGG$COG_category == "-"
# 
# Eukaryota.noKEGG.COG <- Eukaryota.noKEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Eukaryota.noKEGG.noCOG <- Eukaryota.noKEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Eukaryota.noKEGG.noCOG$SequenceID %in% Eukaryota.noKEGG.COG$SequenceID
# 
# Eukaryota.noKEGG <- rbind(Eukaryota.noKEGG.COG,Eukaryota.noKEGG.noCOG[!filter2,])
# 
# #Filtering Sequences in noKEGG that are present in KEGG
# filter3 <- Eukaryota.noKEGG$SequenceID %in% Eukaryota.KEGG$SequenceID
# 
# Eukaryota.noRep <- rbind(Eukaryota.KEGG,Eukaryota.noKEGG[!filter3,])
# 
# write.csv(Eukaryota.noRep,"CSV_files/Eukaryota.TFA_NoRep.csv",row.names = F)
# 
# Eukaryota.noRep$Class <- ifelse(substring(Eukaryota.noRep$Class,nchar(Eukaryota.noRep$Class)-7) == " (Class)",
#                              substring(Eukaryota.noRep$Class,1,nchar(Eukaryota.noRep$Class)-8),
#                              Eukaryota.noRep$Class)
# 
# names(Eukaryota.TPM)[1] <- "SequenceID"
# 
# df.merged <- merge(Eukaryota.TPM,Eukaryota.noRep,by = "SequenceID")
# 
# df.merged$Class[is.na(df.merged$Class)] <- "Unclassified"
# 
# write.csv(df.merged,"CSV_files/Eukaryota.merged.csv",row.names = F)
```

Exploration of the PAR data, the plot created shows the regular line plot of the par data over time, overlayed on a tiled light intensity indicator.

```{r}

partime$norm.par <- partime$par / max(partime$par)

dfOut <- partime

p5 <- ggplot(dfOut)+
  geom_tile(aes(x = lubri,
                y = 0.5,
                fill = par),
           stat = "identity")+
  scale_fill_gradient(low = "darkgrey",
                      high = "yellow")+
  geom_line(aes(x = lubri,
                y = norm.par,
                color = "red"),
                linewidth = 0.5)+
  #scale_x_continuous()+
  theme_classic(base_size = 16)+
  theme(legend.title=element_blank(),
        legend.position = "right",
        legend.key.size = unit(1.5, "cm"),
        axis.text = element_text(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        panel.border = element_rect(linewidth = 1,
                                    colour = "black",
                                    fill = NA),
        strip.background.x =  element_rect(colour = NA,
                                           fill = NA),
        strip.text.x = element_text(face = "bold",
                                    size = 20),
        strip.text.y = element_text(face = "bold",
                                    size = 15))+
  guides(colour = guide_legend(nrow = 3),
         shape = "none")

p5

# ggsave("LI_tile_plot.png", p5, width = 16, height = 9,dpi = 600)

```

First exploration of the stacked box-plots with the PAR-lineplot overlayed.

```{r}
df.merged <- Eukaryota.merged

Class.vec <- unique(df.merged$Class)
n <- length(Class.vec)

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  Class.filter <- df.merged$Class == Class.vec[i]
  df.temp <- df.merged[Class.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,Class.vec)
   }
    
    df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    # df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$Class != "Unclassified",]

top5.vec <- names(table(df.merged2$Class)[order(-table(df.merged2$Class))[1:5]])

top5.filter <- df.count$Class.vec %in% c(top5.vec,"Unclassified")

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day1_morning",
               "Day2_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening")

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","Class.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day")

partime$norm.par <- partime$par / max(partime$par)

p1 <- ggplot(dfOut2)+
  geom_bar(aes(fill = factor(Class.vec,
                             levels = c("Unclassified","Other",top5.vec)),
               y = Count,
               x = datetime),
           position = "stack", stat = "identity")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1))+
  guides(fill = guide_legend(title = "Class"),
         alpha = "none")

scale <- max(partime$par)

p1 <- p1 +
  geom_line(data = partime,
            aes(x = lubri,
                y = norm.par,
                alpha = 0.5))+
  scale_y_continuous(sec.axis = sec_axis(~.*scale, name = "Secondary Y-axis"))

p1
```

Initial exploration of the lineplots connecting all 8 sampling times, with errorbars from the triplicate samples.

```{r}
df.merged <- Eukaryota.merged

Class.vec <- unique(df.merged$Class)
n <- length(Class.vec)

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  Class.filter <- df.merged$Class == Class.vec[i]
  df.temp <- df.merged[Class.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,Class.vec)
   }
    
    # df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$Class != "Unclassified",]

top5.vec <- names(table(df.merged2$Class)[order(-table(df.merged2$Class))[1:10]])

top5.filter <- df.count$Class.vec %in% c(top5.vec,"Unclassified")

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_morning",
               "Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening",
               "Day2_night")

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","Class.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day")

for(i in 1:length(unique(dfOut2$Class.vec))){
  filter <- dfOut2$Class.vec == unique(dfOut2$Class.vec)[i]
  
  dfTemp <- dfOut2[filter,] %>% 
    mutate(norm.data = (Count-min(Count))/(max(Count)-min(Count)))
  
  if(i != 1){
    dfOut3 <- rbind(dfTemp,dfOut3)
  } else {
    dfOut3 <- dfTemp
  }
}

# p2 <- ggplot(data = dfOut3)+
#   geom_line(aes(x = datetime,
#                 y = norm.data,
#                 color = Class.vec))+
#   geom_point(aes(x = datetime,
#                 y = norm.data,
#                 color = Class.vec))+
#   scale_x_continuous(breaks = unique(meta.data$datetime),
#                      labels = unique(meta.data$AssemblyGroup))+
#   theme(axis.text.x = element_text(angle = 90,
#                                    vjust = 0.5,
#                                    hjust=1))
# 
# p2

p2 <- ggplot(data = dfOut2)+
  geom_line(aes(x = datetime,
                y = Count,
                color = Class.vec))+
  geom_point(aes(x = datetime,
                y = Count,
                color = Class.vec))+
  geom_errorbar(aes(x = datetime,
                    y = Count,
                    ymax = Count+sd,
                    ymin = Count-sd))+
  facet_wrap(facets = "Class.vec",
             nrow = 3,
             ncol = 4,
             scales = "free_y")+
  scale_x_continuous(breaks = unique(meta.data$datetime),
                     labels = unique(meta.data$AssemblyGroup))+
  labs(title = "Relative TPM per day",
       y = "TPM per class / total TPM per day",
       x = "Time of sample")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1),
        legend.position = "none")

p2
```

TPM plot per class, broken up with a line connecting samples from day one and a second line connecting samples from day 2. This plot shows the top sum of TPM for each of the top 10 classes as well as for the classes that was not classified. The rest of the classes are summed up in the 'other' category. Next step is to plot the samples with the hour of day on the x-axis rather than the actual time and date that the samples was taken.

```{r}
df.merged <- Eukaryota.merged

Class.vec <- unique(df.merged$Class)
n <- length(Class.vec)

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  Class.filter <- df.merged$Class == Class.vec[i]
  df.temp <- df.merged[Class.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,Class.vec)
   }
    
    # df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$Class != "Unclassified",]

top5.vec <- names(table(df.merged2$Class)[order(-table(df.merged2$Class))[1:10]])

top5.filter <- df.count$Class.vec %in% c(top5.vec,"Unclassified")

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day1_morning",
               "Day2_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening")

name_vec <- COG_categories$Description

names(name_vec) <- COG_categories$Category

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","Class.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime","Day.num","ToD")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day")

partime2 <- partime

filter <- partime2$lubri < min(dfOut2$datetime)

partime2 <- partime2[!filter,]

n <- length(unique(dfOut2$Class.vec))

for(i in 1:n){
  
  filter <- dfOut2$Class.vec == unique(dfOut2$Class.vec)[i]
  
  pt.y <- round(mean(c(max(dfOut2$Count[filter]+dfOut2$sd[filter]), min(dfOut2$Count[filter]-dfOut2$sd[filter]))),5)
  pt.height <- round(max(dfOut2$Count[filter]+dfOut2$sd[filter]) - min(dfOut2$Count[filter]-dfOut2$sd[filter]),5)
  
  partime2.temp <- partime2 %>% 
      mutate(pt.y = pt.y,
             pt.height = pt.height,
             Class.vec = unique(dfOut2$Class.vec)[i])
  
  if(i == 1){
    partime3 <- partime2.temp
  }else{
    partime3 <- rbind(partime3,partime2.temp)
  }
  
}

p3 <- ggplot(dfOut2)+
  geom_tile(data = partime3,
            aes(x = lubri,
                y = pt.y,
                height = pt.height,
                fill = par,
                alpha = .8))+
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Secondary Y-axis"))+
  scale_fill_gradient(low = "black",high = "yellow")+
  geom_line(aes(y = Count,
                x = datetime,
                color = Class.vec,
                linetype = Day.num))+
  geom_point(aes(y = Count,
                 x = datetime,
                 color = Class.vec))+
  geom_errorbar(aes(y = Count,
                    x = datetime,
                    ymin = Count+sd,
                    ymax = Count-sd))+
  facet_wrap(facets = "Class.vec",
             nrow = 4,
             ncol = 3,
             scales = "free_y")+
  scale_x_continuous(breaks = unique(meta.data$datetime),
                     labels = unique(meta.data$AssemblyGroup))+
  labs(title = "Relative TPM per day",
       y = "TPM per class",
       x = "Time of sample")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1),
        legend.position = "none",
        axis.line.y.right = element_blank(),
        axis.title.y.right = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y.right = element_blank(),
        strip.text.x = element_text(size = 10))+
  guides(fill = guide_legend(title = "Class"))

p3

ggsave("COG_Class_plots/Class_light_plot.png",width = 10,height = 9,dpi = 300)
```

Same plot as above, however this one plots sums the COG-categories for the entire dataset instead of summing the Classes. Next step is to plot the samples with the hour of day on the x-axis rather than the actual time and date that the samples was taken. 

```{r}
df.merged <- Eukaryota.merged

filter <- nchar(df.merged$COG_category) == 1
df.merged_1COG <- df.merged[filter,] %>% 
  mutate(COG.untangled = df.merged$COG_category[filter],
         COG_level = "COG1")

df.merged_nCOG <- df.merged[!filter,] %>% 
  mutate(COG.untangled = NA)

for(i in 2:max(nchar(df.merged_nCOG$COG_category))){
  filter <- nchar(df.merged_nCOG$COG_category) == i
  
  df.temp <- df.merged_nCOG[filter,]
  
  for(j in 1:i){
    for(k in 1:nrow(df.temp)){
      df.temp$COG.untangled[k] <- substring(df.temp$COG_category[k],j,j)
    }
    
    df.temp <- df.temp %>% 
      mutate(COG_level = paste("COG",j,sep = ""))
    
    if(i == 2 & j == 1){
      df.untangled <- df.temp
    }else{
      df.untangled <- rbind(df.untangled,df.temp)
    }
  }
  
  if(i == max(nchar(df.merged_nCOG$COG_category))){
    df.merged <- rbind(df.merged_1COG,df.untangled)
  }
}

COG.vec <- unique(df.merged$COG.untangled)
n <- length(COG.vec)

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  COG.filter <- df.merged$COG.untangled == COG.vec[i]
  df.temp <- df.merged[COG.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,COG.vec)
   }
    
    df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$COG.untangled != "-",]

top5.vec <- names(table(df.merged2$COG.untangled)[order(-table(df.merged2$COG.untangled))[1:24]])

top5.filter <- df.count$COG.vec %in% c(top5.vec)

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day1_morning",
               "Day2_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening")

name_vec <- COG_categories$Description

names(name_vec) <- COG_categories$Category

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","COG.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime","Day.num","ToD")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day") #%>% mutate(COG.vec = factor(COG.vec, labels = name_vec))

partime$norm.par <- (partime$par / max(partime$par))*.03

partime2 <- partime

filter <- partime2$lubri < min(dfOut2$datetime)

partime2 <- partime2[!filter,]

n <- length(unique(dfOut2$COG.vec))

for(i in 1:n){
  
  filter <- dfOut2$COG.vec == unique(dfOut2$COG.vec)[i]
  
  pt.y <- round(mean(c(max(dfOut2$Count[filter]+dfOut2$sd[filter]), min(dfOut2$Count[filter]-dfOut2$sd[filter]))),5)
  pt.height <- round(max(dfOut2$Count[filter]+dfOut2$sd[filter]) - min(dfOut2$Count[filter]-dfOut2$sd[filter]),5)
  
  partime2.temp <- partime2 %>% 
      mutate(pt.y = pt.y,
             pt.height = pt.height,
             COG.vec = unique(dfOut2$COG.vec)[i])
  
  if(i == 1){
    partime3 <- partime2.temp
  }else{
    partime3 <- rbind(partime3,partime2.temp)
  }
  
}

p4 <- ggplot(dfOut2)+
  geom_tile(data = partime3,
            aes(x = lubri,
                y = pt.y,
                height = pt.height,
                fill = par,
                alpha = .8))+
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Secondary Y-axis"),
                     label = function(y){y*100})+
  scale_fill_gradient(low = "black",high = "yellow")+
  geom_line(aes(y = Count,
                x = datetime,
                color = COG.vec,
                linetype = Day.num))+
  geom_point(aes(y = Count,
                 x = datetime,
                 color = COG.vec))+
  geom_errorbar(aes(y = Count,
                    x = datetime,
                    ymin = Count+sd,
                    ymax = Count-sd))+
  facet_wrap(facets = "COG.vec",
             nrow = 5,
             ncol = 5,
             scales = "free_y",
             labeller = function(variable,value){return(name_vec[value])})+
  labs(title = "Relative TPM of each COG category for full data-set",
       y = expression(paste("Relative TPM (%)",sep = "",)),
       x = "Day and time of sampling")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1),
        legend.position = "none",
        axis.line.y.right = element_blank(),
        axis.title.y.right = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y.right = element_blank(),
        strip.text.x = element_text(size = 6))+
  guides(fill = guide_legend(title = "COG"))

p4

ggsave("COG_Class_plots/COG_light_plot.png",width = 15,height = 9,dpi = 300)
```

```{r}
top5.class <- c("Dinophyceae",
                "Prymnesiophyceae",
                "Bacillariophyta",
                "Cryptophyceae",
                "Dictyochophyceae")

Class.plot <- top5.class[1:5]

for(l in 1:length(Class.plot)){
  
  df.merged <- Eukaryota.merged
  
  filter1 <- df.merged$Class == Class.plot[l]

  df.merged <- df.merged[filter1,]
  
  filter <- nchar(df.merged$COG_category) == 1
  df.merged_1COG <- df.merged[filter,] %>% 
    mutate(COG.untangled = df.merged$COG_category[filter],
           COG_level = "COG1")
  
  df.merged_nCOG <- df.merged[!filter,] %>% 
    mutate(COG.untangled = NA)
  
  for(i in 2:max(nchar(df.merged_nCOG$COG_category))){
    filter <- nchar(df.merged_nCOG$COG_category) == i
    
    df.temp <- df.merged_nCOG[filter,]
    
    for(j in 1:i){
      for(k in 1:nrow(df.temp)){
        df.temp$COG.untangled[k] <- substring(df.temp$COG_category[k],j,j)
      }
      
      df.temp <- df.temp %>% 
        mutate(COG_level = paste("COG",j,sep = ""))
      
      if(i == 2 & j == 1){
        df.untangled <- df.temp
      }else{
        df.untangled <- rbind(df.untangled,df.temp)
      }
    }
    
    if(i == max(nchar(df.merged_nCOG$COG_category))){
      df.merged <- rbind(df.merged_1COG,df.untangled)
    }
  }
  
  COG.vec <- unique(df.merged$COG.untangled)
  n <- length(COG.vec)
  
  day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
  m <- length(day.vec)
  
  for(i in 1:n){ #Looping through the Classes to count the occurrences.
    
    COG.filter <- df.merged$COG.untangled == COG.vec[i]
    df.temp <- df.merged[COG.filter,]
    
    for(j in 1:m){ #Looping through the sampling time points.
      
     if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
       
       df.count <- data.frame(matrix(ncol = m, nrow = n))
       names(df.count) <- meta.data$SampleName
       
       df.count <- cbind(df.count,COG.vec)
     }
      
      # df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    df.count[i,j] <- sum(df.temp[,day.vec[j]])
      
    }
  }
  
  df.merged2 <- df.merged[df.merged$COG.untangled != "-",]
  
  top5.vec <- names(table(df.merged2$COG.untangled)[order(-table(df.merged2$COG.untangled))[1:24]])
  
  top5.filter <- df.count$COG.vec %in% c(top5.vec)
  
  df.top5 <- df.count[top5.filter,]
  df.other <- df.count[!top5.filter,]
  
  df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))
  
  order.vec <- c("Day1_afternoon",
                 "Day1_evening",
                 "Day1_night",
                 "Day1_morning",
                 "Day2_night",
                 "Day2_morning",
                 "Day2_afternoon",
                 "Day2_evening")
  
  name_vec <- COG_categories$Description
  
  names(name_vec) <- COG_categories$Category
  
  dfOut <- pivot_longer(df.count2,
                        all_of(meta.data$SampleName),
                        names_to = "Day",
                        values_to = "Count") %>% 
    mutate(Count = as.numeric(Count))
  
  dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)
  
  df.summ <- summarySE(data = dfOut, "Count",
                       groupvars = c("Day","COG.vec"))
  
  Day.Time <- meta.data[,c("AssemblyGroup","datetime","Day.num","ToD")] %>% 
    distinct(AssemblyGroup, .keep_all = TRUE)
  
  names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"
  
  dfOut.temp <- merge(df.summ,Day.Time,by = "Day") %>% 
    mutate(Class = Class.plot[l])
  
  if(l == 1){
    dfOut2 <- dfOut.temp
  } else {
    dfOut2 <- rbind(dfOut2,dfOut.temp)
  }
  
}

partime$norm.par <- (partime$par / max(partime$par))*.03

partime2 <- partime

filter <- partime2$lubri < min(dfOut2$datetime)

partime2 <- partime2[!filter,]

n <- length(unique(dfOut2$COG.vec))

for(i in 1:n){
  
  filter <- dfOut2$COG.vec == unique(dfOut2$COG.vec)[i]
  
  pt.y <- round(mean(c(max(dfOut2$Count[filter]+dfOut2$sd[filter]), min(dfOut2$Count[filter]-dfOut2$sd[filter]))),5)
  pt.height <- round(max(dfOut2$Count[filter]+dfOut2$sd[filter]) - min(dfOut2$Count[filter]-dfOut2$sd[filter]),5)
  
  partime2.temp <- partime2 %>% 
      mutate(pt.y = pt.y,
             pt.height = pt.height,
             COG.vec = unique(dfOut2$COG.vec)[i])
  
  if(i == 1){
    partime3 <- partime2.temp
  }else{
    partime3 <- rbind(partime3,partime2.temp)
  }
  
}

p6 <- ggplot(dfOut2)+
  geom_tile(data = partime3,
            aes(x = lubri,
                y = pt.y,
                height = pt.height,
                fill = par,
                alpha = .8))+
  scale_fill_gradient(low = "black",high = "yellow")+
  geom_line(aes(y = Count,
                x = datetime,
                color = Class,
                linetype = Day.num))+
  geom_point(aes(y = Count,
                 x = datetime,
                 color = Class))+
  geom_errorbar(aes(y = Count,
                    x = datetime,
                    ymin = Count+sd,
                    ymax = Count-sd))+
  facet_wrap(facets = "COG.vec",
             nrow = 5,
             ncol = 5,
             scales = "free_y",
             labeller = function(variable,value){return(name_vec[value])})+
  labs(title = paste("Relative TPM of each COG category for Top5 Classes",sep = ""),
       y = expression(paste("TPM",sep = "",)),
       x = "Day and time of sampling")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1),
        legend.position = "right",
        axis.line.y.right = element_blank(),
        axis.title.y.right = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y.right = element_blank(),
        strip.text.x = element_text(size = 6))+
  guides(fill = "none",
         alpha = "none")

p6

save.name <- paste("COG_Class_plots/Top5_COG_light_plot.png",sep = "")

ggsave(save.name,width = 15,height = 9,dpi = 300)
```
Plotting the TPM for each category against the PAR on the x-axis. Due to one day having a much higher light intensity than the other, I log transformed the x-axis. When I separated the days, the data did seem to show some tendencies, either increasing or decreasing with light levels. The next step for this plot is to look at different classes to see if they show more clearer increases or decreases with the light intensity.

```{r}
df.merged <- Eukaryota.merged

filter <- nchar(df.merged$COG_category) == 1
df.merged_1COG <- df.merged[filter,] %>% 
  mutate(COG.untangled = df.merged$COG_category[filter],
         COG_level = "COG1")

df.merged_nCOG <- df.merged[!filter,] %>% 
  mutate(COG.untangled = NA)

for(i in 2:max(nchar(df.merged_nCOG$COG_category))){
  filter <- nchar(df.merged_nCOG$COG_category) == i
  
  df.temp <- df.merged_nCOG[filter,]
  
  for(j in 1:i){
    for(k in 1:nrow(df.temp)){
      df.temp$COG.untangled[k] <- substring(df.temp$COG_category[k],j,j)
    }
    
    df.temp <- df.temp %>% 
      mutate(COG_level = paste("COG",j,sep = ""))
    
    if(i == 2 & j == 1){
      df.untangled <- df.temp
    }else{
      df.untangled <- rbind(df.untangled,df.temp)
    }
  }
  
  if(i == max(nchar(df.merged_nCOG$COG_category))){
    df.merged <- rbind(df.merged_1COG,df.untangled)
  }
}

COG.vec <- unique(df.merged$COG.untangled)
n <- length(COG.vec)

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  COG.filter <- df.merged$COG.untangled == COG.vec[i]
  df.temp <- df.merged[COG.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,COG.vec)
   }
    
    df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$COG.untangled != "-",]

top5.vec <- names(table(df.merged2$COG.untangled)[order(-table(df.merged2$COG.untangled))[1:24]])

top5.filter <- df.count$COG.vec %in% c(top5.vec)

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day1_morning",
               "Day2_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening")

name_vec <- COG_categories$Description

names(name_vec) <- COG_categories$Category

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","COG.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime","par","Day.num","ToD")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day") #%>% mutate(COG.vec = factor(COG.vec, labels = name_vec))

p7 <- ggplot(dfOut2)+
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Secondary Y-axis"))+
  scale_fill_gradient(low = "black",high = "yellow")+
  geom_line(aes(y = Count,
                x = log(par),
                color = COG.vec,
                linetype = Day.num))+
  geom_point(aes(y = Count,
                 x = log(par),
                 color = COG.vec))+
  geom_errorbar(aes(y = Count,
                    x = log(par),
                    ymin = Count+sd,
                    ymax = Count-sd))+
  facet_wrap(facets = "COG.vec",
             nrow = 5,
             ncol = 5,
             scales = "free_y",
             labeller = function(variable,value){return(name_vec[value])})+
  labs(title = "TPM of each COG category for full data-set",
       y = expression(paste("TPM",sep = "",)),
       x = expression(paste("log"[2],"(par) (µmol photons m"^-2," s"^-1,")",sep = "")))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1),
        legend.position = "none",
        axis.line.y.right = element_blank(),
        axis.title.y.right = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y.right = element_blank(),
        strip.text.x = element_text(size = 6))+
  guides(fill = guide_legend(title = "COG"))

p7

ggsave("COG_Class_plots/COG_v_light_plot2.png",width = 15,height = 9,dpi = 300)
```

Initial exploration of the KEGG data, I found that there are so many different KEGGS if I use the first category in the string of the KEGG's after separating them.

```{r}
df.merged <- Eukaryota.merged

df.merged <- separate(df.merged,col = KEGG_ko,into = c("KEGG1","KEGG2","KEGG3","KEGG4","KEGG5","KEGG6","KEGG7","KEGG8"), sep = ",", remove = FALSE, fill = "right", extra = "drop")

# filter <- nchar(df.merged$COG_category) == 1
# df.merged_1COG <- df.merged[filter,] %>% 
#   mutate(COG.untangled = df.merged$COG_category[filter],
#          COG_level = "COG1")
# 
# df.merged_nCOG <- df.merged[!filter,] %>% 
#   mutate(COG.untangled = NA)
# 
# for(i in 2:max(nchar(df.merged_nCOG$COG_category))){
#   filter <- nchar(df.merged_nCOG$COG_category) == i
#   
#   df.temp <- df.merged_nCOG[filter,]
#   
#   for(j in 1:i){
#     for(k in 1:nrow(df.temp)){
#       df.temp$COG.untangled[k] <- substring(df.temp$COG_category[k],j,j)
#     }
#     
#     df.temp <- df.temp %>% 
#       mutate(COG_level = paste("COG",j,sep = ""))
#     
#     if(i == 2 & j == 1){
#       df.untangled <- df.temp
#     }else{
#       df.untangled <- rbind(df.untangled,df.temp)
#     }
#   }
#   
#   if(i == max(nchar(df.merged_nCOG$COG_category))){
#     df.merged <- rbind(df.merged_1COG,df.untangled)
#   }
# }
# 
# COG.vec <- unique(df.merged$COG.untangled)
# n <- length(COG.vec)
# 
# day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
# m <- length(day.vec)
# 
# for(i in 1:n){ #Looping through the Classes to count the occurrences.
#   
#   COG.filter <- df.merged$COG.untangled == COG.vec[i]
#   df.temp <- df.merged[COG.filter,]
#   
#   for(j in 1:m){ #Looping through the sampling time points.
#     
#    if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
#      
#      df.count <- data.frame(matrix(ncol = m, nrow = n))
#      names(df.count) <- meta.data$SampleName
#      
#      df.count <- cbind(df.count,COG.vec)
#    }
#     
#     df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
#     
#   }
# }
# 
# df.merged2 <- df.merged[df.merged$COG.untangled != "-",]
# 
# top5.vec <- names(table(df.merged2$COG.untangled)[order(-table(df.merged2$COG.untangled))[1:24]])
# 
# top5.filter <- df.count$COG.vec %in% c(top5.vec)
# 
# df.top5 <- df.count[top5.filter,]
# df.other <- df.count[!top5.filter,]
# 
# df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))
# 
# order.vec <- c("Day1_afternoon",
#                "Day1_evening",
#                "Day1_night",
#                "Day1_morning",
#                "Day2_night",
#                "Day2_morning",
#                "Day2_afternoon",
#                "Day2_evening")
# 
# name_vec <- COG_categories$Description
# 
# names(name_vec) <- COG_categories$Category
# 
# dfOut <- pivot_longer(df.count2,
#                       all_of(meta.data$SampleName),
#                       names_to = "Day",
#                       values_to = "Count") %>% 
#   mutate(Count = as.numeric(Count))
# 
# dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)
# 
# df.summ <- summarySE(data = dfOut, "Count",
#                      groupvars = c("Day","COG.vec"))
# 
# Day.Time <- meta.data[,c("AssemblyGroup","datetime","Day.num","ToD")] %>% 
#   distinct(AssemblyGroup, .keep_all = TRUE)
# 
# names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"
# 
# dfOut2 <- merge(df.summ,Day.Time,by = "Day") #%>% mutate(COG.vec = factor(COG.vec, labels = name_vec))
# 
# partime$norm.par <- (partime$par / max(partime$par))*.03
# 
# partime2 <- partime
# 
# filter <- partime2$lubri < min(dfOut2$datetime)
# 
# partime2 <- partime2[!filter,]
# 
# n <- length(unique(dfOut2$COG.vec))
# 
# for(i in 1:n){
#   
#   filter <- dfOut2$COG.vec == unique(dfOut2$COG.vec)[i]
#   
#   pt.y <- round(mean(c(max(dfOut2$Count[filter]+dfOut2$sd[filter]), min(dfOut2$Count[filter]-dfOut2$sd[filter]))),5)
#   pt.height <- round(max(dfOut2$Count[filter]+dfOut2$sd[filter]) - min(dfOut2$Count[filter]-dfOut2$sd[filter]),5)
#   
#   partime2.temp <- partime2 %>% 
#       mutate(pt.y = pt.y,
#              pt.height = pt.height,
#              COG.vec = unique(dfOut2$COG.vec)[i])
#   
#   if(i == 1){
#     partime3 <- partime2.temp
#   }else{
#     partime3 <- rbind(partime3,partime2.temp)
#   }
#   
# }
# 
# p8 <- ggplot(dfOut2)+
#   geom_tile(data = partime3,
#             aes(x = lubri,
#                 y = pt.y,
#                 height = pt.height,
#                 fill = par,
#                 alpha = .8))+
#   scale_y_continuous(sec.axis = sec_axis(~ ., name = "Secondary Y-axis"),
#                      label = function(y){y*100})+
#   scale_fill_gradient(low = "black",high = "yellow")+
#   geom_line(aes(y = Count,
#                 x = datetime,
#                 color = COG.vec,
#                 linetype = Day.num))+
#   geom_point(aes(y = Count,
#                  x = datetime,
#                  color = COG.vec))+
#   geom_errorbar(aes(y = Count,
#                     x = datetime,
#                     ymin = Count+sd,
#                     ymax = Count-sd))+
#   facet_wrap(facets = "COG.vec",
#              nrow = 5,
#              ncol = 5,
#              scales = "free_y",
#              labeller = function(variable,value){return(name_vec[value])})+
#   labs(title = "Relative TPM of each COG category for full data-set",
#        y = expression(paste("Relative TPM (%)",sep = "",)),
#        x = "Day and time of sampling")+
#   theme_classic()+
#   theme(axis.text.x = element_text(angle = 90,
#                                    vjust = 0.5,
#                                    hjust=1),
#         legend.position = "none",
#         axis.line.y.right = element_blank(),
#         axis.title.y.right = element_blank(),
#         axis.text.y.right = element_blank(),
#         axis.ticks.y.right = element_blank(),
#         strip.text.x = element_text(size = 6))+
#   guides(fill = guide_legend(title = "COG"))
# 
# p8
# 
# ggsave("COG_Class_plots/COG_light_plot.png",width = 15,height = 9,dpi = 300)
```
