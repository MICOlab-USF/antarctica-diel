---
title: "Differential expression analysis"
author: "Andreas Norlin"
date: "2025-01-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","patchwork","stringi",
                  "RColorBrewer")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

bioc.packages <- c("phyloseq","DESeq2")

if(!all(bioc.packages %in% installed.packages()[,"Package"])){
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(bioc.packages[!(bioc.packages %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)
library(RColorBrewer)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

TPM <- T

if(TPM == TRUE){
  load("CSV_files/Subsections.RData",verbose = TRUE)
}else{
  load("CSV_files/Subsections_numreads.RData",verbose = TRUE)
}

```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r, Data setup}

Input_data <- Bact.Sub

for(i in 1:nrow(Input_data)){
  if(i == 1){
    n_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  }
  m_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

Input_data <- separate(Input_data,col = KEGG_ko,into = KEGG_columns,
                     sep = ",", remove = FALSE, fill = "right", extra = "drop")

# Input_data <- Input_data[!is.na(Input_data$Class),]
# Input_data$Class_K1 <- paste(Input_data$Class,Input_data$KEGG1,sep = "_")

KO_paths <- read.csv("KO_pathway.csv")

Input_data$K1_paths <- unlist(lapply(Input_data$KEGG1,
                                     function(x){
                                       ifelse(x == "-","",KO_paths$ko[KO_paths$K1 == x])}))

source("summary_count.R")

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")

df.count <- summary_count(Input_data,Col_vec = day.vec,Col_filter = "KEGG1")

names(df.count) <- unlist(lapply(names(df.count),
                                 function(x){unlist(strsplit(x,
                                                             split = "_",
                                                             fixed = TRUE))[1]}))

df_meta <- meta.data[,c("SampleID","SampleName","AssemblyGroup","Day.num","ToD")] %>%
  mutate(ToD = factor(ToD,levels = c("morning","afternoon","evening","night")))


# Optional extra step to average the replicates of each day ####
AvgDays <- FALSE

if(AvgDays == TRUE){
  # Input_data <- Bact.Sub
  
  Input_data <- df.count
  
  vec_assembly <- unique(meta.data$AssemblyGroup)
  
  for(i in 1:length(vec_assembly)){
    if(i == 1){
  
      df_means <- row.names(Input_data)
    }
  
    df_temp <- Input_data[,meta.data$SampleID[meta.data$AssemblyGroup == vec_assembly[i]]]
  
    meta_temp <- df_meta %>%
      distinct(AssemblyGroup,.keep_all = TRUE) %>%
      filter(AssemblyGroup == vec_assembly[i])
  
    vec <- rowMeans(df_temp)
    # vec <- rowSums(df_temp)
    df_means <- cbind.data.frame(df_means,vec)
  
    names(df_means)[i+1] <- vec_assembly[i]
  }
  
  # creating factors for the ToD in order to analyse the time points chronologically
  df_meta <- df_meta %>%
    distinct(AssemblyGroup,.keep_all = TRUE)
  
  df.count <- df_means[,-1]
  rm(list = c("df_means"))
}

# Rounding data to become integer ####

df.0filtered <- df.count[apply(df.count, 1, function(x){sum(x == 0)}) < 1,]

if(TPM == TRUE){
 countData <- round(df.0filtered*1000,3) 
}else{
  countData <- round(df.0filtered,3)
}

countData <- cbind.data.frame("SequenceID" = row.names(df.0filtered),countData)

head(countData)
tail(countData)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

Day_toggle <- "ToD"

GroupOI <- c("morning","afternoon","evening","night")#[c(4)]

if(AvgDays == TRUE){
  filter <- c("SequenceID",df_meta$AssemblyGroup[df_meta$ToD %in% GroupOI])
} else {
  filter <- c("SequenceID",df_meta$SampleID[df_meta$ToD %in% GroupOI]) 
}

if(Day_toggle == "ToD"){
  dds <- DESeqDataSetFromMatrix(countData=countData[,filter],
                              colData=df_meta[df_meta$ToD %in% GroupOI,], 
                              design=~ToD, tidy = TRUE)
} else if(Day_toggle == "Day.num"){
  dds <- DESeqDataSetFromMatrix(countData=countData[,filter],
                              colData=df_meta[df_meta$ToD %in% GroupOI,], 
                              design=~Day.num, tidy = TRUE)
}



dds

# Now weâ€™re ready to run DESEQ function ---------------------------------------

dds <- DESeq(dds)

# Take a look at the results table --------------------------------------------

res <- results(dds)

head(results(dds, tidy = TRUE))

# Summary of differential gene expression -------------------------------------

summary(res) #summary of results

# Sort summary list by p-value ------------------------------------------------

res <- res[order(res$padj,decreasing = F),]
head(res)

```

```{r, Volcano Plot}
pAdj_thresh <- 0.01

x_range <- min(max(abs(res$log2FoldChange),na.rm = TRUE),150)
y_range <- min(max(-log10(res$pvalue),na.rm = TRUE),150)

#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res,
     plot(log2FoldChange,
          -log10(pvalue),
          pch=20,
          main="Volcano plot",
          ylim=c(0,y_range),
          xlim=c(-x_range,x_range)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res,
            padj<pAdj_thresh ),
     points(log2FoldChange,-log10(pvalue),
            pch=20,
            col="blue"))

with(subset(res,
            padj<pAdj_thresh & abs(log2FoldChange)>1 & !is.na(padj<pAdj_thresh)),
     points(log2FoldChange, -log10(pvalue),
            pch=20,
            col="red"))


```

```{r}
dfOut <- res[res$padj<pAdj_thresh & !is.na(res$padj<pAdj_thresh),]
dfOut$ko <- row.names(dfOut)

source("pathway_API.R")

vec <- rep(NA,nrow(dfOut))

for(i in 1:nrow(dfOut)){
  vec[i] <- pathway_API(dfOut$ko[i])$name
  
  if(is.na(vec[i])){
    vec[i] <- dfOut$ko[i]
  }
}

row.names(dfOut) <- vec

n <- min(nrow(dfOut),6)
par(mfrow=c(2,3))

for(i in 1:n){
  plotCounts(dds,
             gene=dfOut$ko[i],
             intgroup=Day_toggle,
             main = row.names(dfOut)[i])
}
```

