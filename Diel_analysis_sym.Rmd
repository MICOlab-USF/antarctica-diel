---
title: "Diel_Bacteria_sym"
author: "Andreas Norlin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","phyloseq","patchwork",
                  "DESeq2","stringi")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

#Loading the meta.data: meta.data1 is the Assmebly group and the sequencing ID (sample ID),
#meta.data2 is the data about sampling time and site.

meta.data1 <- read.csv("CSV_files/dielRNA_eukrythmic.tsv", sep = "\t")
meta.data2 <- read.csv("sample_metadata.csv") %>% 
  mutate(Sample_ID = paste("HM",Sample_ID,sep = ""))

names(meta.data2)[names(meta.data2) == "Sample_ID"] <- "SampleID"

#Combining meta.data1 and meta.data2 and making the lubri string a data + time saved in datetime
meta.data <- merge(meta.data1,meta.data2,by = "SampleID") %>% 
  mutate(datetime = ymd(substring(lubri,1,10))+hms(substring(lubri,12,19)))

meta.data <- separate(meta.data, col = AssemblyGroup, into = c("Day.num","ToD"),sep = "_",remove = FALSE, fill = "right", extra = "drop")

# meta.data$lubri <- with_tz(mdy_hms(meta.data$datetime, tz = "UTC"),
#                            tz = "America/Santiago")

COG_categories <- read.csv("COG_categories.csv",sep = ",")

Full.merged <- read.csv("CSV_files/Full.merged.csv")

par1 <- read.delim("NBP2113pguv.d342",  sep = " ", header =FALSE)
par2<- read.delim("NBP2113pguv.d343",  sep = " ", header =FALSE)
par3<- read.delim("NBP2113pguv.d344",  sep = " ", header =FALSE)

par = rbind(par1, par2, par3)[-1,c(1,2,3,10)]
names(par) <- c("juliendatetime","date", "time", "par")

partime <- par %>% 
  separate(juliendatetime, c("yearday","hour", "min", "sec"), sep = ":" ) %>% 
  unite(utctime, hour, min, sec, sep=":")  %>% 
  mutate(utcdatetime = paste(date, utctime))

partime$lubri <- with_tz(mdy_hms(partime$utcdatetime, tz = "UTC"),
                         tz = "America/Santiago")

for(i in 1:nrow(meta.data)){

  filter.above <- partime$lubri >= meta.data$datetime[i]
  filter.below <- partime$lubri < meta.data$datetime[i]
  
  vec.above <- partime[partime$lubri == min(partime$lubri[filter.above]),]
  vec.below <- partime[partime$lubri == max(partime$lubri[filter.below]),]
  
  meta.data$par[i] <- mean(vec.above$par,vec.below$par)
  
}

m <- 1
time.int <- ms("05.00")
for(i in 1:nrow(partime)){
  if(i == 1){
    vec <- NA
    vec.slide <- NA
    n <- 1
  }
  
  test.vec <- partime$lubri[i] - partime$lubri[m]
  
  if(test.vec > time.int){
    m <- i
    
    vec[n] <- i
    
    n <- n+1
  }
  
}

partime <- partime[vec,]
```


```{r Loading and cleaning the raw data}
# tax.func <- read.csv("CSV_files/TaxonomicAndFunctionalAnnotations.csv", sep = "\t")
# 
# #Splitting the column with full_classification into seperate columns
# tax.func <- separate(tax.func,
#                      col = full_classification,
#                      into = c("Domain","Supergroup","Division","Class","Order","Family","Genus","Species"),
#                      sep = "; ",
#                      remove = FALSE,
#                      fill = "right",
#                      extra = "drop")
# 
# tax.func <- tax.func[tax.func$Domain != "",]
# 
# #Cleaning up data by removing blank spaces at the beginning of entries in the newly separated columns.
# Class_hierarchy <- c("Domain","Supergroup","Division","Class","Order","Family","Genus","Species")
# 
# for(i in 1:length(Class_hierarchy)){
#   Col_filter <- names(tax.func) == Class_hierarchy[i]
# 
#   tax.func[,Col_filter] <- ifelse(substring(tax.func[,Col_filter],1,1) == " ",
#                                           substring(tax.func[,Col_filter],2),
#                                           tax.func[,Col_filter])
# }
# 
# #Removing the .p after sequence names, in order to remove duplicate sequences later.
# tax.func$SequenceID <- unlist(lapply(tax.func$SequenceID,
#                                       function(x){unlist(strsplit(x,split = ".",fixed = TRUE))[1]}))
# 
# salmon.TPM <- read.csv("CSV_files/salmon.merged.TPM.subset5.csv")
# filter <- salmon.TPM$Name %in% tax.func$SequenceID
# 
# Full.TPM <- salmon.TPM[filter,]
# 
# #Filtering out the sequences present in the Taxonomy and functional annotations data, but not in the TPM
# filter <- tax.func$SequenceID %in% Full.TPM$Name
# 
# tax.func <- tax.func[filter,]
# 
# #Seperates sequences with a KEGG from the sequences that don't
# filter <- tax.func$KEGG_ko != "-"
# 
# Full.KEGG <- tax.func[filter,]
# Full.noKEGG <- tax.func[!filter,]
# 
# #Creates a filter for the sequences that have KEGGs to seperate COGs and noCOGs
# filter1 <- Full.KEGG$COG_category == "-"
# 
# Full.KEGG.COG <- Full.KEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Full.KEGG.noCOG <- Full.KEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Full.KEGG.noCOG$SequenceID %in% Full.KEGG.COG$SequenceID
# 
# Full.KEGG <- rbind(Full.KEGG.COG,Full.KEGG.noCOG[!filter2,])
# 
# #Creates a filter for the sequences that doesn't have KEGGs to seperate COGs and noCOGs
# filter1 <- Full.noKEGG$COG_category == "-"
# 
# Full.noKEGG.COG <- Full.noKEGG[!filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# Full.noKEGG.noCOG <- Full.noKEGG[filter1,] %>%
#   distinct(SequenceID, .keep_all = TRUE)
# 
# #Removes sequences from noCOG that is present in COG
# filter2 <- Full.noKEGG.noCOG$SequenceID %in% Full.noKEGG.COG$SequenceID
# 
# Full.noKEGG <- rbind(Full.noKEGG.COG,Full.noKEGG.noCOG[!filter2,])
# 
# #Filtering Sequences in noKEGG that are present in KEGG
# filter3 <- Full.noKEGG$SequenceID %in% Full.KEGG$SequenceID
# 
# Full.noRep <- rbind(Full.KEGG,Full.noKEGG[!filter3,])
# 
# write.csv(Full.noRep,"CSV_files/tax.func_NoRep.csv",row.names = F)
# 
# names(Full.TPM)[1] <- "SequenceID"
# 
# df.merged <- merge(Full.TPM,Full.noRep,by = "SequenceID")
# 
# write.csv(df.merged,"CSV_files/Full.merged.csv",row.names = F)
```

```{r Subsetting full.merged}

Prok.Sub <- Full.merged[Full.merged$Domain != "Eukaryota",]
Euk.Sub <- Full.merged[Full.merged$Domain == "Eukaryota",]
Bact.Sub <- Full.merged[Full.merged$Domain == "Bacteria",]

```


```{r Cleaning categories}

Full.noRep$Class <- ifelse(substring(Full.noRep$Class,nchar(Full.noRep$Class)-7) == " (Class)",
                           substring(Full.noRep$Class,1,nchar(Full.noRep$Class)-8),
                           Full.noRep$Class) #Is this statement even needed?

for(i in 1:length(Class_hierarchy)){
  Col_filter <- names(df.merged) == Class_hierarchy[i]
  row_filter <- is.na(df.merged[,Col_filter])

  df.merged[row_filter,Col_filter] <- "Unclassified"
}

```

```{r}
df.merged <- Bact.Sub

source("split_function.R")

for(i in 1:nrow(df.merged)){
  if(i == 1){
    n_KEGG <- length(unlist(split_function(df.merged$KEGG_ko[i],",")))
  }
  m_KEGG <- length(unlist(split_function(df.merged$KEGG_ko[i],",")))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

df.merged <- separate(df.merged,col = KEGG_ko,into = KEGG_columns,
                      sep = ",", remove = FALSE, fill = "right", extra = "drop")

for(i in 1:length(KEGG_columns)){
  if(i == 1){
    vec_kegg <- unique(df.merged[,KEGG_columns[i]])
  }else{
    vec <- df.merged[,KEGG_columns[i]]
    
    NA_filter <- is.na(vec)
    
    if(any(NA_filter)){
      vec <- vec[!NA_filter]
    }
    
    vec_kegg <- unique(c(vec_kegg,unique(vec)))
  }
}

#####
# kegg_API <- function(kegg){
#   pathway <- system(paste0("curl https://rest.kegg.jp/link/pathway/", kegg), intern=TRUE)
#   l <- length(pathway)
# 
#   ifelse(l != 0,
#          stri_sub(pathway[[l]], 16),
#          "NA")
# }
# 
# Ks <- unique(df.merged$KEGG1[df.merged$KEGG1 != "-"])[-3]
# 
# Ks <- vec_kegg[!(vec_kegg %in% KO_paths$K1)]
# 
# koslist <- Ks[Ks != "-"]
# 
# paths <- unlist(lapply(koslist,kegg_API))
# KO_paths2 <- data.frame(koslist, paths)
# names(KO_paths2) <- c("K1", "ko")

# for(i in 1:nrow(df.merged)){
#   if(i == 1){
#     Ko_path <- rep(NA,nrow(df.merged))
#   }
# 
#   vec <- df.merged$KEGG1[i]
#   if(vec %in% KO_paths$K1){
#    vec_paths <- KO_paths$ko[KO_paths$K1 == vec]
# 
#    if(vec_paths == ""){
#      Ko_path[i] <- "Unclassified"
#    } else{
#     Ko_path[i] <- vec_paths
#    }
#   } else {
#     Ko_path[i] <- "Unclassified"
#   }
# }
#####

Prok_KO_paths <- read.csv("KO_pathway.csv")

for(i in 1:nrow(df.merged)){
  if(i == 1){
    Ko_path <- rep(NA,nrow(df.merged))
  }

  vec <- df.merged$KEGG1[i]

  vec_paths <- Prok_KO_paths$ko[Prok_KO_paths$K1 == vec]

  if(vec == "-"){
    vec_paths <- ""
  }

  if(vec_paths == ""){
    for(j in 2:length(KEGG_columns)){
      if(j == 2){
        stop_vec <- TRUE
      }

      if(stop_vec){
        vec <- df.merged[i,KEGG_columns[j]]

        if(is.na(vec)){
          stop_vec <- FALSE
          vec_paths <- ""
        } else {
          vec_paths <- Prok_KO_paths$ko[Prok_KO_paths$K1 == vec]
        }

        if(vec_paths != ""){
          stop_vec <- FALSE
        }
      }
    }


  }
  if(vec_paths == ""){
    vec_paths <- "Unclassified"
  }

  Ko_path[i] <- vec_paths
}

df.merged$K1_path <- Ko_path
kegg.vec <- unique(df.merged$K1_path)
n <- length(kegg.vec)

# df.merged <- df.merged[df.merged$K1_path != "Unclassified",]

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
m <- length(day.vec)

for(i in 1:n){ #Looping through the Classes to count the occurrences.
  
  kegg.filter <- df.merged$K1_path == kegg.vec[i]
  df.temp <- df.merged[kegg.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     names(df.count) <- meta.data$SampleName
     
     df.count <- cbind(df.count,kegg.vec)
   }
    
    df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
    # df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

df.merged2 <- df.merged[df.merged$K1_path != "Unclassified",]

# df.merged2 <- df.merged

top5.vec <- names(table(df.merged2$K1_path)[order(-table(df.merged2$K1_path))[1:10]])

top5.filter <- df.count$kegg.vec %in% c(top5.vec,"Unclassified")
# top5.filter <- df.count$kegg.vec %in% c(top5.vec)

df.top5 <- df.count[top5.filter,]
df.other <- df.count[!top5.filter,]

df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))

order.vec <- c("Day1_afternoon",
               "Day1_evening",
               "Day1_night",
               "Day1_morning",
               "Day2_night",
               "Day2_morning",
               "Day2_afternoon",
               "Day2_evening")

dfOut <- pivot_longer(df.count2,
                      all_of(meta.data$SampleName),
                      names_to = "Day",
                      values_to = "Count") %>% 
  mutate(Count = as.numeric(Count))

dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)

df.summ <- summarySE(data = dfOut, "Count",
                     groupvars = c("Day","kegg.vec"))

Day.Time <- meta.data[,c("AssemblyGroup","datetime")] %>% 
  distinct(AssemblyGroup, .keep_all = TRUE)

names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"

dfOut2 <- merge(df.summ,Day.Time,by = "Day")
dfOut2_O.U <- dfOut2[(dfOut2$kegg.vec %in% c("Other","Unclassified")),]

dfOut2 <- dfOut2[!(dfOut2$kegg.vec %in% c("Other","Unclassified")),]

partime$norm.par <- partime$par / max(partime$par)

p1 <- ggplot(dfOut2)+
  geom_bar(aes(fill = factor(kegg.vec,
                             levels = c("Unclassified","Other",top5.vec)),
               y = Count,
               x = datetime),
           position = "stack", stat = "identity")+
  scale_x_continuous(breaks = unique(meta.data$datetime),
                     labels = unique(meta.data$AssemblyGroup))+
  labs(title = "All Bacteria",
       y = "Fraction of TPM",
       x = "Time of sample",
       caption = "This is a caption")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1))+
  guides(fill = guide_legend(title = "kegg"),
         alpha = "none")+
  geom_point(data = dfOut2_O.U,
             aes(y = Count,
                 x = datetime,
                 color = kegg.vec,
                 shape = kegg.vec))

# scale <- max(partime$par)
# 
# p1 <- p1 +
#   geom_line(data = partime,
#             aes(x = lubri,
#                 y = norm.par,
#                 alpha = 0.5))+
#   scale_y_continuous(sec.axis = sec_axis(~.*scale, name = "Secondary Y-axis"))

p1

```

```{r}
Order_of_interest <- c("Alteromonadales","Oceanospirillales","Sphingomonadales","Cellvibrionales")
Genus_of_interest <- c("Paraglaciecola","Colwellia")

df.merged <- Bact.Sub

source("split_function.R")

# Setting up and splitting kegg columns ####

for(i in 1:nrow(df.merged)){
  if(i == 1){
    n_KEGG <- length(unlist(split_function(df.merged$KEGG_ko[i],",")))
  }
  m_KEGG <- length(unlist(split_function(df.merged$KEGG_ko[i],",")))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

df.merged <- separate(df.merged,col = KEGG_ko,into = KEGG_columns,
                      sep = ",", remove = FALSE, fill = "right", extra = "drop")

for(i in 1:length(KEGG_columns)){
  if(i == 1){
    vec_kegg <- unique(df.merged[,KEGG_columns[i]])
  }else{
    vec <- df.merged[,KEGG_columns[i]]
    
    NA_filter <- is.na(vec)
    
    if(any(NA_filter)){
      vec <- vec[!NA_filter]
    }
    
    vec_kegg <- unique(c(vec_kegg,unique(vec)))
  }
}

# Kegg Path lookup####

Prok_KO_paths <- read.csv("KO_pathway.csv")

for(i in 1:nrow(df.merged)){
  if(i == 1){
    Ko_path <- rep(NA,nrow(df.merged))
  }

  vec <- df.merged$KEGG1[i]

  vec_paths <- Prok_KO_paths$ko[Prok_KO_paths$K1 == vec]

  if(vec == "-"){
    vec_paths <- ""
  }

  if(vec_paths == ""){
    for(j in 2:length(KEGG_columns)){
      if(j == 2){
        stop_vec <- TRUE
      }

      if(stop_vec){
        vec <- df.merged[i,KEGG_columns[j]]

        if(is.na(vec)){
          stop_vec <- FALSE
          vec_paths <- ""
        } else {
          vec_paths <- Prok_KO_paths$ko[Prok_KO_paths$K1 == vec]
        }

        if(vec_paths != ""){
          stop_vec <- FALSE
        }
      }
    }


  }
  if(vec_paths == ""){
    vec_paths <- "Unclassified"
  }

  Ko_path[i] <- vec_paths
}

df.merged$K1_path <- Ko_path
kegg.vec <- unique(df.merged$K1_path)
n <- length(kegg.vec)

#Counting TPM for keggs for each order of interest####
df.merged_copy <- df.merged
df.merged_NoNA <- df.merged_copy[!is.na(df.merged_copy$Order),]

for(order_idx in Order_of_interest){
  
  order_filter <- df.merged_NoNA$Order == order_idx
  
  df.merged <- df.merged_NoNA[order_filter,]
  
  day.vec <- paste(meta.data$SampleID,"_quant",sep = "")
  m <- length(day.vec)
  
  for(i in 1:n){ #Looping through the Classes to count the occurrences.
    
    kegg.filter <- df.merged$K1_path == kegg.vec[i]
    df.temp <- df.merged[kegg.filter,]
    
    for(j in 1:m){ #Looping through the sampling time points.
      
     if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
       
       df.count <- data.frame(matrix(ncol = m, nrow = n))
       names(df.count) <- meta.data$SampleName
       
       df.count <- cbind(df.count,kegg.vec)
     }
      
      df.count[i,j] <- sum(df.temp[,day.vec[j]])/sum(df.merged[,day.vec[j]])
      # df.count[i,j] <- sum(df.temp[,day.vec[j]])
      
    }
  }
  
  df.merged2 <- df.merged[df.merged$K1_path != "Unclassified",]
  
  # df.merged2 <- df.merged
  
  top5.vec <- names(table(df.merged2$K1_path)[order(-table(df.merged2$K1_path))[1:5]])
  
  top5.filter <- df.count$kegg.vec %in% c(top5.vec,"Unclassified")
  # top5.filter <- df.count$kegg.vec %in% c(top5.vec)
  
  df.top5 <- df.count[top5.filter,]
  df.other <- df.count[!top5.filter,]
  
  df.count2 <- rbind(df.top5,c(colSums(df.other[,1:24]),"Other"))
  
  order.vec <- c("Day1_afternoon",
                 "Day1_evening",
                 "Day1_night",
                 "Day1_morning",
                 "Day2_night",
                 "Day2_morning",
                 "Day2_afternoon",
                 "Day2_evening")
  
  dfOut <- pivot_longer(df.count2,
                        all_of(meta.data$SampleName),
                        names_to = "Day",
                        values_to = "Count") %>% 
    mutate(Count = as.numeric(Count))
  
  dfOut$Day <- substring(dfOut$Day,1,nchar(dfOut$Day)-1)
  
  df.summ <- summarySE(data = dfOut, "Count",
                       groupvars = c("Day","kegg.vec"))
  
  Day.Time <- meta.data[,c("AssemblyGroup","datetime")] %>% 
    distinct(AssemblyGroup, .keep_all = TRUE)
  
  names(Day.Time)[names(Day.Time) == "AssemblyGroup"] <- "Day"
  
  dfOut2 <- merge(df.summ,Day.Time,by = "Day") %>% 
    mutate(Facet_name = order_idx)
  
  name_vec <- paste("dfOut2_",order_idx,sep = "")
  assign(name_vec,dfOut2,envir = globalenv())
}
#####



dfOut3 <- rbind.data.frame(dfOut2_Alteromonadales,
                           dfOut2_Cellvibrionales,
                           dfOut2_Oceanospirillales,
                           dfOut2_Sphingomonadales)

level_vec <- unique(dfOut3$kegg.vec)[!(unique(dfOut3$kegg.vec) %in% c("Unclassified","Other"))]

dfOut_O.U <- dfOut3[(dfOut3$kegg.vec %in% c("Unclassified","Other")),]
dfOut3 <- dfOut3[!(dfOut3$kegg.vec %in% c("Unclassified","Other")),]

p1 <- ggplot(dfOut3)+
  geom_bar(aes(fill = factor(kegg.vec,
                             levels = c("Unclassified","Other",level_vec)
                             ),
               y = Count,
               x = datetime),
           position = "stack", stat = "identity")+
  geom_point(data = dfOut_O.U,
             aes(x = datetime,
                 y = Count,
                 color = kegg.vec))+
  scale_x_continuous(breaks = unique(meta.data$datetime),
                     labels = unique(meta.data$AssemblyGroup))+
  facet_wrap(facets = "Facet_name",
             nrow = 2,
             ncol = 2,
             scales = "free_y")+
  labs(title = "Orders",
       y = "Fraction of TPM",
       x = "Time of sample")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust=1))+
  guides(fill = guide_legend(title = "kegg"),
         alpha = "none")

p1
```

```{r}
# kegg_API <- function(kegg){
#   pathway <- system(paste0("curl https://rest.kegg.jp/link/pathway/", kegg), intern=TRUE)
#   l <- length(pathway)
# 
#   ifelse(l != 0,
#          stri_sub(pathway[[l]], 16),
#          "NA")
# }

top_kos <- level_vec

name <- character(length=0)
class <- character(length=0)

for(i in 1:length(top_kos)) {
  pathway <- system(paste0("curl https://rest.kegg.jp/get/", top_kos[[i]]), intern=TRUE)
  name[[i]] <- pathway[[2]]
  class[[i]] <-pathway[[3]]
}

topkos_w_info <-data.frame(top_kos, name, class)
```

