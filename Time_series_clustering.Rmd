---
title: "Time_series_clustering"
author: "Andreas Norlin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","patchwork","stringi",
                  "RColorBrewer","pheatmap")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

bioc.packages <- c("phyloseq","DESeq2","rain")

if(!all(bioc.packages %in% installed.packages()[,"Package"])){
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(bioc.packages[!(bioc.packages %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)
library(RColorBrewer)
library(pheatmap)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

library(rain)

TPM <- TRUE

if(TPM == TRUE){
  load("CSV_files/Subsections.RData",verbose = TRUE)
}else{
  load("CSV_files/Subsections_numreads.RData",verbose = TRUE)
}

```



```{r, Data setup}

# Input_data <- Bact.Sub
Input_data <- rbind(Euk.Sub,Bact.Sub)

for(i in 1:nrow(Input_data)){
  if(i == 1){
    n_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  }
  m_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

Input_data <- separate(Input_data,col = KEGG_ko,into = KEGG_columns,
                     sep = ",", remove = FALSE, fill = "right", extra = "drop")

KO_paths_Bact <- read.csv("KO_pathway.csv")
KO_paths_Euk <- read.csv("KO_pathway_Euk.csv")

KO_paths <- rbind(KO_paths_Euk,
                  KO_paths_Bact[!(KO_paths_Bact$K1 %in% KO_paths_Euk$K1),])

Input_data$K1_paths <- unlist(lapply(Input_data$KEGG1,
                                     function(x){
                                       ifelse(x == "-","",KO_paths$ko[KO_paths$K1 == x])}))

# Input_data <- Input_data[!is.na(Input_data$Class),]
Input_data$Domain_K1 <- paste(Input_data$Domain,Input_data$KEGG1,sep = "_")

source("summary_count.R")

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")

df.count <- summary_count(Input_data,Col_vec = day.vec,Col_filter = "Domain_K1")

names(df.count) <- unlist(lapply(names(df.count),
                                 function(x){unlist(strsplit(x,
                                                             split = "_",
                                                             fixed = TRUE))[1]}))

df_meta <- meta.data[,c("SampleID","SampleName","AssemblyGroup","Day.num","ToD")] %>%
  mutate(ToD = factor(ToD,levels = c("morning","afternoon","evening","night")))


# Optional extra step to average the replicates of each day ####
AvgDays <- F

if(AvgDays == TRUE){
  # Input_data <- Bact.Sub
  
  Input_data <- df.count
  
  vec_assembly <- unique(meta.data$AssemblyGroup)
  
  for(i in 1:length(vec_assembly)){
    if(i == 1){
  
      df_means <- row.names(Input_data)
    }
  
    df_temp <- Input_data[,meta.data$SampleID[meta.data$AssemblyGroup == vec_assembly[i]]]
  
    meta_temp <- df_meta %>%
      distinct(AssemblyGroup,.keep_all = TRUE) %>%
      filter(AssemblyGroup == vec_assembly[i])
  
    vec <- rowMeans(df_temp)
    # vec <- rowSums(df_temp)
    df_means <- cbind.data.frame(df_means,vec)
  
    names(df_means)[i+1] <- vec_assembly[i]
  }
  
  # creating factors for the ToD in order to analyse the time points chronologically
  df_meta <- df_meta %>%
    distinct(AssemblyGroup,.keep_all = TRUE)
  
  df.count <- df_means[,-1]
  rm(list = c("df_means"))
}

```

```{r}

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

time_points <- (0:7)*6

# Detrending the dataset, by subtracting the linear model values from the data
dfOut <- t(apply(df.count[,Order_vec],1,function(x){x - lm(unlist(x)~time_points)$fitted.values}))

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))
# dfOut <- df.count

dfOut <- cbind.data.frame(dfOut,"Gene" = row.names(dfOut))[-3,]

# dfOut <- pivot_longer(dfOut,cols = 1:8,names_to = "ToD",values_to = "TPM") %>% 
#   mutate(ToD = factor(ToD,
#                       levels = Order_vec))

random_select <- sample(nrow(dfOut))

dfOut_long <- pivot_longer(dfOut[random_select,],cols = 1:8,names_to = "ToD",values_to = "TPM")
dfOut_long$ToD <- unlist(lapply(dfOut_long$ToD,function(x){(1:8)[Order_vec == x]}))

ggplot(dfOut_long)+
  geom_line(aes(x = ToD,
                y = TPM,
                group = Gene))+
  scale_x_continuous(breaks = 1:8,
                     labels = Order_vec)+
  theme(legend.position = "none")
  
```

```{r}

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

df_meta$time_points <- unlist(lapply(df_meta$AssemblyGroup,function(x){((0:7)*6)[Order_vec == x]}))
time_order <- order(df_meta$time_points)

time_points <- df_meta$time_points[time_order]

# Detrending the dataset, by subtracting the linear model values from the data
dfOut <- t(apply(df.count[,time_order],1,function(x){x - lm(unlist(x)~time_points)$fitted.values}))

rainresult <- rain(t(dfOut),
                   period = 24,
                   deltat = 6,
                   nr.series = 3,
                   verbose = T)

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))
# dfOut <- df.count

dfOut <- cbind.data.frame(dfOut,"Gene" = row.names(dfOut))#[-3,]

rainresult$Gene <- rownames(rainresult)

dfOut2 <- merge(dfOut,rainresult,by = "Gene")
# dfOut2$Group <- paste(dfOut2$phase,dfOut2$peak.shape,sep = "_")

dfOut2 <- pivot_longer(dfOut2,cols = 2:25,names_to = "ToD",values_to = "TPM")
# dfOut2$ToD <- unlist(lapply(dfOut2$ToD,function(x){(1:8)[Order_vec == x]}))
dfOut2$ToD <- unlist(lapply(dfOut2$ToD,function(x){df_meta$time_points[df_meta$SampleID == x]}))

df.summ <- summarySE(dfOut2,measurevar = "TPM",groupvars = c("Gene","ToD"))

dfOut2 <- pivot_wider(df.summ,id_cols = "Gene",
                      names_from = "ToD",
                      values_from = "TPM")

dfOut2 <- merge(dfOut2,rainresult,by = "Gene")
dfOut2 <- dfOut2[order(dfOut2$pVal),]


q_val <- 0.01
abh_metric <- 1:nrow(dfOut2)*(q_val/nrow(dfOut2))
dfOut2$Sig[dfOut2$pVal <= abh_metric] <- "Sig"
dfOut2$Sig[dfOut2$pVal > abh_metric] <- "Insig"

dfOut2_long <- pivot_longer(dfOut2,cols = 2:9,names_to = "ToD",values_to = "TPM")

phase_list <- c("Morning","Afternoon","Evening","Night")

# I should probably do some significance adjusting to reduce the number of false positives,
# Like Holms correction.

# dfOut2_long$Sig <- unlist(lapply(dfOut2_long$pVal,function(x){ifelse(x < 0.01,"Sig","Insig")}))
dfOut2_long$phase <- unlist(lapply(dfOut2_long$phase,function(x){phase_list[c(6,12,18,24) == x]}))

ggplot(dfOut2_long)+
  geom_line(aes(x = as.numeric(ToD),
                y = TPM,
                group = Gene,
                alpha = Sig,
                color = Sig))+
  scale_x_continuous(breaks = c(0,6,12,18,24,30,36,42),
                     labels = c(phase_list,phase_list))+
  scale_color_manual(values = c("Sig" = "black",
                                "insig" = "gray"))+
  scale_alpha_manual(values = c("Sig" = 1,
                                   "Insig" = .05))+
  facet_rep_grid(facets = phase~peak.shape)+
  labs(y = "Scaled TPM",
       x = "Time of Day")+
  theme_classic()+
  theme(legend.position = "none")

file.name <- "Time_series_plots/UntagledTC.png"
ggsave(file.name,dpi = 300,width = 15,height = 12)

```


```{r}
# Explorations of the rain output:
unique(rainresult$phase)
unique(rainresult$peak.shape)
sum(rainresult$pVal < 0.0001)
sum(rainresult$pVal < 0.01)
sum(rainresult$pVal < 0.05)
rainresult[(rainresult$pVal < 0.01),]
unique(rainresult$phase[(rainresult$pVal < 0.01)])
unique(paste(rainresult$phase,rainresult$peak.shape,sep = "_"))
```

