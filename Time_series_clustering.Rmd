---
title: "Time_series_clustering"
author: "Andreas Norlin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","patchwork","stringi",
                  "RColorBrewer","pheatmap","ggh4x")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

bioc.packages <- c("phyloseq","DESeq2","rain","limma","clusterProfiler")

if(!all(bioc.packages %in% installed.packages()[,"Package"])){
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(bioc.packages[!(bioc.packages %in% installed.packages()[,"Package"])])
}

library(Rmisc)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(lubridate)
library(RColorBrewer)
library(pheatmap)
library(ggh4x)
library(dplyr)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

library(rain)
library(limma)
library(clusterProfiler)

TPM <- TRUE
```



```{r, Data setup}

if(TPM == TRUE){
  load("CSV_files/Subsections.RData",verbose = TRUE)
}else{
  load("CSV_files/Subsections_numreads.RData",verbose = TRUE)
}

Input_data <- Bact.Sub
# Input_data <- rbind(Euk.Sub,Prok.Sub)

for(i in 1:nrow(Input_data)){
  if(i == 1){
    n_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  }
  m_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

Input_data <- separate(Input_data,col = KEGG_ko,into = KEGG_columns,
                     sep = ",", remove = FALSE, fill = "right", extra = "drop")

KO_paths_Bact <- read.csv("KO_pathway.csv")
KO_paths_Euk <- read.csv("KO_pathway_Euk.csv")

KO_paths <- rbind(KO_paths_Euk,
                  KO_paths_Bact[!(KO_paths_Bact$K1 %in% KO_paths_Euk$K1),])

Input_data$K1_paths <- unlist(lapply(Input_data$KEGG1,
                                     function(x){
                                       ifelse(x == "-","",KO_paths$ko[KO_paths$K1 == x])}))

# Input_data <- Input_data[!is.na(Input_data$Class),]
Input_data$Classi_K1 <- paste(Input_data$classification,Input_data$KEGG1,sep = "_")

source("summary_count.R")

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")

df.count <- summary_count(Input_data,Col_vec = day.vec,Col_filter = "Classi_K1")

names(df.count) <- unlist(lapply(names(df.count),
                                 function(x){unlist(strsplit(x,
                                                             split = "_",
                                                             fixed = TRUE))[1]}))

df_meta <- meta.data[,c("SampleID","SampleName","AssemblyGroup","Day.num","ToD")] %>%
  mutate(ToD = factor(ToD,levels = c("morning","afternoon","evening","night")))


# Optional extra step to average the replicates of each day ####
AvgDays <- F

if(AvgDays == TRUE){
  # Input_data <- Bact.Sub
  
  Input_data <- df.count
  
  vec_assembly <- unique(meta.data$AssemblyGroup)
  
  for(i in 1:length(vec_assembly)){
    if(i == 1){
  
      df_means <- row.names(Input_data)
    }
  
    df_temp <- Input_data[,meta.data$SampleID[meta.data$AssemblyGroup == vec_assembly[i]]]
  
    meta_temp <- df_meta %>%
      distinct(AssemblyGroup,.keep_all = TRUE) %>%
      filter(AssemblyGroup == vec_assembly[i])
  
    vec <- rowMeans(df_temp)
    # vec <- rowSums(df_temp)
    df_means <- cbind.data.frame(df_means,vec)
  
    names(df_means)[i+1] <- vec_assembly[i]
  }
  
  # creating factors for the ToD in order to analyse the time points chronologically
  df_meta <- df_meta %>%
    distinct(AssemblyGroup,.keep_all = TRUE)
  
  df.count <- df_means[,-1]
  rm(list = c("df_means"))
}

```

```{r}

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

time_points <- (0:7)*6

# Detrending the dataset, by subtracting the linear model values from the data
dfOut <- t(apply(df.count[,Order_vec],1,function(x){x - lm(unlist(x)~time_points)$fitted.values}))

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))
# dfOut <- df.count

dfOut <- cbind.data.frame(dfOut,"Gene" = row.names(dfOut))[-3,]

# dfOut <- pivot_longer(dfOut,cols = 1:8,names_to = "ToD",values_to = "TPM") %>% 
#   mutate(ToD = factor(ToD,
#                       levels = Order_vec))

random_select <- sample(nrow(dfOut))

dfOut_long <- pivot_longer(dfOut[random_select,],cols = 1:8,names_to = "ToD",values_to = "TPM")
dfOut_long$ToD <- unlist(lapply(dfOut_long$ToD,function(x){(1:8)[Order_vec == x]}))

ggplot(dfOut_long)+
  geom_line(aes(x = ToD,
                y = TPM,
                group = Gene))+
  scale_x_continuous(breaks = 1:8,
                     labels = Order_vec)+
  theme(legend.position = "none")
  
```

```{r}

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

Time_vec <- c(0,6,12,18,24,30,36,42)

df_meta$time_points <- unlist(lapply(df_meta$AssemblyGroup,function(x){Time_vec[Order_vec == x]}))

time_order <- order(df_meta$time_points)

df_meta <- df_meta[time_order,]

# Detrending the dataset, by subtracting the linear model values from the data
# dfOut <- t(apply(df.count[,df_meta$SampleID],1,function(x){x - lm(unlist(x)~df_meta$time_points)$fitted.values}))
dfOut <- t(apply(df.count[,df_meta$SampleID],1,function(x){x - lm(unlist(x)~df_meta$time_points)$fitted.values}))

rainresult <- rain(t(dfOut),
                   period = 24,
                   deltat = 6,
                   nr.series = 3,
                   verbose = T)

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))
# dfOut <- df.count

dfOut <- cbind.data.frame(dfOut,"Gene" = row.names(dfOut))#[-3,]

rainresult$Gene <- rownames(rainresult)

dfOut2 <- merge(dfOut,rainresult,by = "Gene")
# dfOut2$Group <- paste(dfOut2$phase,dfOut2$peak.shape,sep = "_")

dfOut2 <- pivot_longer(dfOut2,cols = 2:25,names_to = "ToD",values_to = "TPM")
# dfOut2$ToD <- unlist(lapply(dfOut2$ToD,function(x){(1:8)[Order_vec == x]}))
dfOut2$ToD <- unlist(lapply(dfOut2$ToD,function(x){df_meta$time_points[df_meta$SampleID == x]}))

df.summ <- summarySE(dfOut2,measurevar = "TPM",groupvars = c("Gene","ToD"))

dfOut2 <- pivot_wider(df.summ,id_cols = "Gene",
                      names_from = "ToD",
                      values_from = "TPM")

dfOut2 <- merge(dfOut2,rainresult,by = "Gene")
dfOut2 <- dfOut2[order(dfOut2$pVal),]

p_adj <- TRUE
alpha <- 0.01

if(p_adj == TRUE){
  q_val <- alpha
  abh_metric <- 1:nrow(dfOut2)*(q_val/nrow(dfOut2))
  dfOut2$Sig[dfOut2$pVal <= abh_metric] <- "Sig"
  dfOut2$Sig[dfOut2$pVal > abh_metric] <- "Insig" 
}

dfOut2 <- separate(dfOut2,
                   col = Gene,
                   into = c("Domain","ko"),
                   sep = "_",
                   remove = FALSE,
                   fill = "right",
                   extra = "drop")

dfOut2_long <- pivot_longer(dfOut2,cols = 4:11,names_to = "ToD",values_to = "TPM")

phase_list <- c("Morning","Afternoon","Evening","Night")

if(p_adj == FALSE){
  dfOut2_long$Sig <- unlist(lapply(dfOut2_long$pVal,function(x){ifelse(x < alpha,"Sig","Insig")}))
}
dfOut2_long$phase <- unlist(lapply(dfOut2_long$phase,function(x){phase_list[c(6,12,18,24) == x]}))

# -----------------
#An attempt at coloring the output based on the density of significant line
# dfOut2_test <- dfOut2_long
# 
# groups_vec <- unique(paste(dfOut2_long$Domain,
#                            dfOut2_long$phase,
#                            dfOut2_long$peak.shape))
# 
# for(i in 1:length(groups_vec)){
#   filter <- paste(dfOut2_long$Domain,
#                   dfOut2_long$phase,
#                   dfOut2_long$peak.shape) == groups_vec[i]
# 
#   dfOut2_test$line_count[filter] <- sum(dfOut2_long$Sig[filter] == "Sig")
# }
# 
# ggplot(dfOut2_test) +
#   geom_line(aes(x = as.numeric(ToD),
#                 y = TPM,
#                 group = Gene,
#                 color = line_count,
#                 alpha = Sig)) +
#   scale_x_continuous(breaks = Time_vec,
#                      labels = c(phase_list, phase_list)) +
#   scale_color_gradient(low = "black",high = "darkgreen")+
#   scale_alpha_manual(values = c("Sig" = 1, "Insig" = .05)) +
#   facet_nested(
#     factor(peak.shape, levels = c(6, 12, 18), labels = c("+6", "+12", "+18")) +
#       factor(Domain, levels = c("Eukaryota", "Bacteria", "Archaea")) ~
#       factor(phase, levels = c("Morning", "Afternoon", "Evening", "Night"))
#   ) +
#   labs(y = "Scaled TPM", x = "Time of Day") +
#   theme_classic() +
#   theme(legend.position = "none")
# -------------------

ggplot(dfOut2_long)+
  geom_line(aes(x = as.numeric(ToD),
                y = TPM,
                group = Gene,
                alpha = Sig,
                color = Sig))+
  scale_x_continuous(breaks = Time_vec,
                     labels = c(phase_list,phase_list))+
  scale_color_manual(values = c("Sig" = "black",
                                "insig" = "gray"))+
  scale_alpha_manual(values = c("Sig" = 1,
                                   "Insig" = .05))+
  # facet_rep_grid(facets = phase~peak.shape)+
  facet_nested(factor(peak.shape,
                      levels = c(6,12,18),
                      labels = c("+6","+12","+18"))
               # + factor(Domain,
               #                   levels = c("Eukaryota",
               #                              "Bacteria",
               #                              "Archaea"))
               ~ factor(phase,
                        levels = c("Morning","Afternoon",
                                   "Evening","Night")))+
  labs(y = "Scaled TPM",
       x = "Time of Day")+
  theme_classic()+
  theme(legend.position = "none")

file.name <- "Time_series_plots/UntagledTC.png"
ggsave(file.name,dpi = 300,width = 20,height = 12)

df_Diel <- dfOut2

```


```{r}
# Explorations of the rain output:

paste("Number of cyclical genes with a p value lower than 0.0001:",sum(rainresult$pVal < 0.0001))
paste("Number of cyclical genes selected using the FDR BH metric:",sum(dfOut2$Sig == "Sig"))
paste("Number of cyclical genes with a p value lower than 0.01:",sum(rainresult$pVal < 0.01))
paste("Number of cyclical genes with a p value lower than 0.05:",sum(rainresult$pVal < 0.05))

Percent_Arch <- round((nrow(df_Diel[df_Diel$Domain == "Archaea" & df_Diel$Sig == "Sig",]) / nrow(df_Diel[df_Diel$Domain == "Archaea",]))*100,2)
Percent_Bact <- round((nrow(df_Diel[df_Diel$Domain == "Bacteria" & df_Diel$Sig == "Sig",]) / nrow(df_Diel[df_Diel$Domain == "Bacteria",]))*100,2)
Percent_Euk <- round((nrow(df_Diel[df_Diel$Domain == "Eukaryota" & df_Diel$Sig == "Sig",]) / nrow(df_Diel[df_Diel$Domain == "Eukaryota",]))*100,2)

paste("Percentage of Archeae genes that are significantly cyclical:", Percent_Arch)
paste("Percentage of Eukaryotic genes that are significantly cyclical:", Percent_Euk)
paste("Percentage of Bacteria genes that are significantly cyclical:", Percent_Bact)

```

```{r}

Domains <- c("Eukaryota","Bacteria","Archaea")
phases <- c(6,12,18,24)
peak.shapes <- c(6,12,18)

n <- 1

df_DielSummed <- data.frame(matrix(nrow = 36,ncol = 4))

for(i in 1:length(Domains)){
  df.temp <- df_Diel[df_Diel$Domain == Domains[i],]
  
  for(j in 1:length(phases)){
    df.temp2 <- df.temp[df.temp$phase == phases[j],]
    
    for(k in 1:length(peak.shapes)){
      df.temp3 <- df.temp2[df.temp2$peak.shape == peak.shapes[k],]
      
      vec <- sum(df.temp3$Sig == "Sig") / nrow(df.temp)
      # vec <- sum(df.temp3$Sig == "Sig") / nrow(df_Diel)
      
      df_DielSummed[n,] <- c(Domains[i],phases[j],peak.shapes[k],round(vec*100,2))
      n <- n+1
    }
  }
}

names(df_DielSummed) <- c("Domain","phase","peak.shape","PerSig")

ggplot(df_DielSummed)+
  geom_bar(aes(y = as.numeric(PerSig),
               x = factor(peak.shape,levels = c(6,12,18),
                          labels = c("+6","+12","+18"))),
           stat = "Identity")+
  facet_nested(.~factor(Domain,levels = c("Eukaryota","Bacteria","Archaea")) +
                 factor(phase,levels = c(6,12,18,24),
                               labels = c("Morning","Afternoon","Evening","Night")))+
  labs(title = "Percent of genes within Domain, that is significantly cyclical",
       x = "Hours after peak, trough occurs",
       y = "%",
       caption = paste(   "Column facets indicate Domain (top), and which time of day the peak of the cycle occurs (bottom).",
                       "\n The x-axis indicates how many hours after the peak, that the valley occurs. The percentage is cal-",
                       "\n culated based on the total number of genes within each domain.                                                 "))+
  theme_classic()

file.name <- "Time_series_plots/PerSig_cycles.png"
ggsave(file.name,dpi = 300,width = 10,height = 7.5)

```

```{r,echo=FALSE,include=FALSE,results='hide'}
# library(rain)
# library(ggplot2)
# library(dplyr)
# library(tidyverse)
# library(Rmisc)
# library(ggh4x)
# 
# salmon.TPM <- read.csv("CSV_files/salmon.merged.TPM.subset5.csv")
# load("meta_data.RData",verbose = T)
# 
# df_meta <- meta.data[,c("SampleID","SampleName","AssemblyGroup","Day.num","ToD")] %>%
#   mutate(ToD = factor(ToD,levels = c("morning","afternoon","evening","night")))
```


```{r}

Time1 <- Sys.time()

names(salmon.TPM) <- unlist(lapply(names(salmon.TPM),
                                 function(x){unlist(strsplit(x,
                                                             split = "_",
                                                             fixed = TRUE))[1]}))
rownames(salmon.TPM) <- salmon.TPM$Name
salmon.TPM <- salmon.TPM[,-1]

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

Time_vec <- c(0,6,12,18,24,30,36,42)

df_meta$time_points <- unlist(lapply(df_meta$AssemblyGroup,function(x){Time_vec[Order_vec == x]}))

time_order <- order(df_meta$time_points)

df_meta<- df_meta[time_order,]
# time_points <- df_meta$time_points[time_order]

# Detrending the dataset, by subtracting the linear model values from the data
dfOut <- t(apply(salmon.TPM[,df_meta$SampleID],1,function(x){x - lm(unlist(x)~df_meta$time_points)$fitted.values}))

rainresult <- rain(t(dfOut),
                   period = 24,
                   deltat = 6,
                   nr.series = 3,
                   verbose = T)

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))

dfOut <- cbind.data.frame(dfOut,"ID" = row.names(dfOut))

rainresult$ID <- rownames(rainresult)

dfOut <- merge(dfOut,rainresult,by = "ID")

dfOut <- pivot_longer(dfOut,cols = 2:25,names_to = "ToD",values_to = "TPM")
dfOut$ToD <- unlist(lapply(dfOut$ToD,function(x){df_meta$AssemblyGroup[df_meta$SampleID == x]}))

df.summ <- summarySE(dfOut,measurevar = "TPM",groupvars = c("ID","ToD"))

dfOut <- pivot_wider(df.summ,id_cols = "ID",
                      names_from = "ToD",
                      values_from = "TPM")

dfOut <- merge(dfOut,rainresult,by = "ID")
dfOut <- dfOut[order(dfOut$pVal),]

rm(list = c("rainresult","df.summ"))

p_adj <- TRUE
alpha <- 0.05

if(p_adj == TRUE){
  q_val <- alpha
  abh_metric <- 1:nrow(dfOut)*(q_val/nrow(dfOut))
  dfOut$Sig[dfOut$pVal <= abh_metric] <- "Sig"
  dfOut$Sig[dfOut$pVal > abh_metric] <- "Insig" 
}

# dfOut_long <- pivot_longer(dfOut,cols = 4:11,names_to = "ToD",values_to = "TPM")
# 
# phase_list <- c("Morning","Afternoon","Evening","Night")
# 
# if(p_adj == FALSE){
#   dfOut_long$Sig <- unlist(lapply(dfOut_long$pVal,function(x){ifelse(x < alpha,"Sig","Insig")}))
# }
# dfOut_long$phase <- unlist(lapply(dfOut_long$phase,function(x){phase_list[c(6,12,18,24) == x]}))

# -----------------
#An attempt at coloring the output based on the density of significant line
# dfOut_test <- dfOut_long
# 
# groups_vec <- unique(paste(dfOut_long$Domain,
#                            dfOut_long$phase,
#                            dfOut_long$peak.shape))
# 
# for(i in 1:length(groups_vec)){
#   filter <- paste(dfOut_long$Domain,
#                   dfOut_long$phase,
#                   dfOut_long$peak.shape) == groups_vec[i]
# 
#   dfOut_test$line_count[filter] <- sum(dfOut_long$Sig[filter] == "Sig")
# }
# 
# ggplot(dfOut_test) +
#   geom_line(aes(x = as.numeric(ToD),
#                 y = TPM,
#                 group = ID,
#                 color = line_count,
#                 alpha = Sig)) +
#   scale_x_continuous(breaks = Time_vec,
#                      labels = c(phase_list, phase_list)) +
#   scale_color_gradient(low = "black",high = "darkgreen")+
#   scale_alpha_manual(values = c("Sig" = 1, "Insig" = .05)) +
#   facet_nested(
#     factor(peak.shape, levels = c(6, 12, 18), labels = c("+6", "+12", "+18")) +
#       factor(Domain, levels = c("Eukaryota", "Bacteria", "Archaea")) ~
#       factor(phase, levels = c("Morning", "Afternoon", "Evening", "Night"))
#   ) +
#   labs(y = "Scaled TPM", x = "Time of Day") +
#   theme_classic() +
#   theme(legend.position = "none")
# -------------------

# p1 <- ggplot(dfOut_long)+
#   geom_line(aes(x = as.numeric(ToD),
#                 y = TPM,
#                 group = ID,
#                 alpha = Sig,
#                 color = Sig),
#             linewidth = .05)+
#   scale_x_continuous(breaks = Time_vec,
#                      labels = c(phase_list,phase_list))+
#   scale_color_manual(values = c("Sig" = "black",
#                                 "insig" = "gray"))+
#   scale_alpha_manual(values = c("Sig" = 1,
#                                    "Insig" = .005))+
#   # facet_rep_grid(facets = phase~peak.shape)+
#   facet_nested(factor(phase,
#                       levels = c("Morning","Afternoon",
#                                  "Evening","Night")) ~ 
#                  factor(peak.shape,
#                         levels = c(6,12,18),
#                         labels = c("+6","+12","+18")))+
#   labs(y = "Scaled TPM",
#        x = "Time of Day")+
#   theme_classic()+
#   theme(legend.position = "none")
# 
# file.name <- "Time_series_plots/UntagledTC_AllContigs.png"
# ggsave(plot = p1,filename = file.name,dpi = 300,width = 15,height = 12)

# save(dfOut,df_meta,file = "CSV_files/rainResults_RegSpace.RData")

Sys.time()-Time1
```



```{r}
load("CSV_files/rainResults_RegSpace.RData",verbose = TRUE)

df_meta <- df_meta %>% distinct(AssemblyGroup,.keep_all = T)
names(dfOut)[2:9] <- unlist(lapply(names(dfOut)[2:9],function(x){df_meta$time_points[df_meta$AssemblyGroup == x]}))

phase_list <- c("Morning","Afternoon","Evening","Night")

dfOut$phase <- unlist(lapply(dfOut$phase,function(x){phase_list[c(6,12,18,24) == x]}))

dfOut_long <- pivot_longer(dfOut,cols = 2:9,names_to = "ToD",values_to = "TPM")

Time_vec <- c(0,6,12,18,24,30,36,42)

p1 <- ggplot(dfOut_long)+
  geom_line(aes(x = as.numeric(ToD),
                y = TPM,
                group = ID,
                alpha = Sig,
                color = Sig),
            linewidth = .05)+
  scale_x_continuous(breaks = Time_vec,
                     labels = c(phase_list,phase_list))+
  scale_color_manual(values = c("Sig" = "black",
                                "insig" = "gray"))+
  scale_alpha_manual(values = c("Sig" = 1,
                                   "Insig" = .005))+
  # facet_rep_grid(facets = phase~peak.shape)+
  facet_nested(factor(phase,
                      levels = c("Morning","Afternoon",
                                 "Evening","Night")) ~
                 factor(peak.shape,
                        levels = c(6,12,18),
                        labels = c("+6","+12","+18")))+
  labs(y = "Scaled TPM",
       x = "Time of Day")+
  theme_classic()+
  theme(legend.position = "none")

# file.name <- "Time_series_plots/UntagledTC_AllContigs.png"
# ggsave(plot = p1,filename = file.name,dpi = 300,width = 15,height = 12)
```


```{r}

# load("CSV_files/Full.merged.RData",verbose = TRUE)
# 
# for(i in 1:nrow(Full.merged)){
#   if(i == 1){
#     n_KEGG <- length(unlist(strsplit(Full.merged$KEGG_ko[i],",",fixed = TRUE)))
#   }
#   m_KEGG <- length(unlist(strsplit(Full.merged$KEGG_ko[i],",",fixed = TRUE)))
# 
#   if(m_KEGG > n_KEGG){
#     n_KEGG <- m_KEGG
#   }
# }
# 
# KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")
# 
# Full.merged <- separate(Full.merged,col = KEGG_ko,into = KEGG_columns,
#                      sep = ",", remove = FALSE, fill = "right", extra = "drop")
# 
# KO_paths_Bact <- read.csv("KO_pathway.csv")
# KO_paths_Euk <- read.csv("KO_pathway_Euk.csv")
# 
# KO_paths <- rbind(KO_paths_Euk,KO_paths_Bact[!(KO_paths_Bact$K1 %in% KO_paths_Euk$K1),])
# 
# Full.merged$K1_paths <- unlist(lapply(Full.merged$KEGG1,
#                                       function(x){ifelse(x == "-","",KO_paths$ko[KO_paths$K1 == x])}))
# 
# names(Full.merged)[grep("quant",names(Full.merged))] <- unlist(lapply(names(Full.merged)[grep("quant",names(Full.merged))],
#                                                                       function(x){unlist(strsplit(x,split = "_",fixed = TRUE))[1]}))
# 
# column.drop_list <- c(meta.data$SampleID,"counts","max_pid","full_classification","Unnamed..0","X")
# 
# Full.merged <- Full.merged[,!(names(Full.merged) %in% column.drop_list)]
# names(Full.merged)[names(Full.merged) == "SequenceID"] <- "ID"
# 
# load("CSV_files/rainResults_RegSpace.RData",verbose = TRUE)
# 
# phase_list <- c("Morning","Afternoon","Evening","Night")
# dfOut$phase <- unlist(lapply(dfOut$phase,function(x){phase_list[c(6,12,18,24) == x]}))
# 
# Full.merged_rain <- merge(dfOut,Full.merged, by = "ID",all.x = TRUE)
# 
# df_meta <- df_meta %>% distinct(AssemblyGroup,.keep_all = T)
# 
# save(Full.merged_rain,meta.data,df_meta,file = "CSV_files/FullMerged_rain.RData")

```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

vec <- sample(nrow(Full.merged_rain),1000,replace = F)

names(Full.merged_rain)[2:9] <- unlist(lapply(names(Full.merged_rain)[2:9],function(x){df_meta$time_points[df_meta$AssemblyGroup == x]}))

Full.merged_rain$TaxFunc <- unlist(lapply(Full.merged_rain$Domain,function(x){ifelse(is.na(x),"No","Yes")}))

Full.merged_rain[Full.merged_rain$TaxFunc == "Yes",2:9] <- Full.merged_rain[Full.merged_rain$TaxFunc == "Yes",2:9]+3

dfOut_long <- pivot_longer(Full.merged_rain[vec,],cols = 2:9,names_to = "ToD",values_to = "TPM")

Time_vec <- c(0,6,12,18,24,30,36,42)
phase_list <- c("Morning","Afternoon","Evening","Night")

p1 <- ggplot(dfOut_long)+
  geom_line(aes(x = as.numeric(ToD),
                y = TPM,
                group = ID,
                alpha = Sig,
                color = Sig),
            linewidth = .05)+
  scale_x_continuous(breaks = Time_vec,
                     labels = c(phase_list,phase_list))+
  scale_color_manual(values = c("Sig" = "black",
                                "Insig" = "gray"))+
  scale_alpha_manual(values = c("Sig" = 1,
                                   "Insig" = .01))+
  # facet_rep_grid(facets = phase~peak.shape)+
  facet_nested(factor(phase,
                      levels = c("Morning","Afternoon",
                                 "Evening","Night")) ~
                 factor(peak.shape,
                        levels = c(6,12,18),
                        labels = c("+6","+12","+18")))+
  labs(y = "Scaled TPM",
       x = "Time of Day")+
  theme_classic()+
  theme(legend.position = "none")

p1
```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

for(i in 1:length(phase.peaks)){
  if(i == 1){
    vec.sig <- rep(NA,length(phase.peaks))
    vec.insig <- rep(NA,length(phase.peaks))
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  
  df.temp <- Full.merged_rain[filter,]
  
  vec.sig[i] <- sum(df.temp$Sig == "Sig")
  vec.insig[i] <- sum(df.temp$Sig == "Insig")
  
  if(i == length(phase.peaks)){
    dfOut <- cbind.data.frame(phase.peaks,"Sig" = vec.sig,"Insig" = vec.insig)
  }
}

axis2.Scale <- 200000/1e6

ggplot()+
  geom_bar(data = dfOut%>%pivot_longer(cols = 2:3,
                                       names_to = "Sig",
                                       values_to = "Value"),
           aes(x = phase.peaks,
               y = Value/1e6,
               fill = Sig),
           position = "stack",stat = "identity")+
  geom_point(data = dfOut,
             aes(x = phase.peaks,
                 y = (Sig/(Sig+Insig))*axis2.Scale*100))+
  scale_y_continuous(sec.axis = sec_axis(~./axis2.Scale, name = "% Significant"))+
  scale_fill_manual(values = c("Sig" = "dodgerblue",
                               "Insig" = "goldenrod"))+
  theme_classic()

# dfOut$Sig.scaled <- dfOut$Sig/(dfOut$Sig+dfOut$Insig)
# dfOut$Insig.scaled <- dfOut$Insig/(dfOut$Sig+dfOut$Insig)
# 
# ggplot(dfOut %>% pivot_longer(cols = 4:5,
#                               names_to = "Sig.scaled",
#                               values_to = "Value"))+
#   geom_bar(aes(x = phase.peaks,
#                y = Value,
#                fill = Sig.scaled),
#            position = "stack",stat = "identity")+
#   scale_fill_manual(values = c("Sig.scaled" = "dodgerblue",
#                                "Insig.scaled" = "goldenrod"))+
#   theme_classic()

```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

COG_categories <- sort(unique(unlist(lapply(unique(Full.merged_rain$COG_category),
                                            function(x){strsplit(x,split = "")}))))

Full.merged_rain$COG_category[is.na(Full.merged_rain$COG_category)] <- "na"

COG_categories <- c(COG_categories,"na")

for(i in 1:length(phase.peaks)){
  if(i == 1){
    df.sig <- data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(COG_categories)))
    df.insig <- data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(COG_categories)))
    
    names(df.sig) <- COG_categories
    df.sig$phase.peaks <- phase.peaks
    
    names(df.insig) <- COG_categories
    df.insig$phase.peaks <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  for(j in 1:length(COG_categories)){
    df.sig[i,j] <- length(grep(COG_categories[j],df.temp$COG_category[df.temp$Sig == "Sig"]))
    df.insig[i,j] <- length(grep(COG_categories[j],df.temp$COG_category[df.temp$Sig == "Insig"]))
  }
  
  if(i == length(phase.peaks)){
    df.sig$Total <- apply(df.sig[,COG_categories],1,sum)
    df.insig$Total <- apply(df.insig[,COG_categories],1,sum)
    
    df.sig$Sig <- "Sig"
    df.insig$Sig <- "Insig"
    
    dfOut <- rbind.data.frame(df.sig,df.insig)
    
    rm(list = c("df.sig","df.insig","df.temp"))
  }
}
dfOut$TotPhase <- apply(dfOut[,COG_categories],1,sum)

dfOut2 <- dfOut %>% pivot_longer(cols = all_of(c(COG_categories,"TotPhase")),
                                 names_to = "COG",
                                 values_to = "Count")

ggplot(dfOut2[!(dfOut2$COG %in% c("na","TotPhase")),])+
  geom_bar(aes(fill = Sig,
               x = COG,
               y = Count),
           position = "stack",stat = "identity")+
  facet_wrap(facets = "phase.peaks", nrow = 4,ncol = 3)+
  theme_classic()



dfOut2$TotPhase.COG <- rep(dfOut2$Count[dfOut2$Sig == "Insig"] + dfOut2$Count[dfOut2$Sig == "Sig"],2)


dfOut2 <- dfOut2[dfOut2$Sig == "Sig",]
dfOut2$Sig.rat <- dfOut2$Count/dfOut2$TotPhase.COG
dfOut2$ColorGroup <- NA

for(i in 1:length(phase.peaks)){
  filter <- dfOut2$phase.peaks == phase.peaks[i]
  df.temp <- dfOut2[filter,]
  
  dfOut2$ColorGroup[filter] <- unlist(lapply(df.temp$Sig.rat,
                                             function(x){ifelse(x > df.temp$Sig.rat[df.temp$COG == "TotPhase"],"Higher","Lower")}))
  
  if(i == length(phase.peaks)){
    dfOut2$ColorGroup[dfOut2$COG == "na"] <- "unannotated"
    dfOut2$ColorGroup[dfOut2$COG == "TotPhase"] <- "TotPhase"
  }
}

ggplot(dfOut2)+
  geom_point(aes(x = factor(COG,levels = c("TotPhase","na",COG_categories[!(COG_categories %in% c("na","TotPhase"))])),
                 y = Sig.rat*100,
                 color = ColorGroup),
             size = 4)+
  scale_color_manual(values = c("unannotated" = "black",
                                "Higher" = "red",
                                "Lower" = "blue"))+
  facet_wrap(facets = "phase.peaks", nrow = 4,ncol = 3)+
  theme_classic()

ggplot(dfOut2)+
  geom_bar(aes(x = factor(COG,levels = c("TotPhase","na",COG_categories[!(COG_categories %in% c("na","TotPhase"))])),
               y = Sig.rat*100,
               fill = ColorGroup),
             position = "stack",stat = "identity")+
  scale_fill_manual(values = c("unannotated" = "black",
                                "Higher" = "red",
                                "Lower" = "blue"))+
  facet_wrap(facets = "phase.peaks", nrow = 4,ncol = 3)+
  theme_classic()

df.sig <- dfOut[1:12,c(COG_categories,"TotPhase")]
df.insig <- dfOut[13:24,c(COG_categories,"TotPhase")]

row.names(df.sig) <- dfOut$phase.peaks[1:12]
row.names(df.insig) <- dfOut$phase.peaks[13:24]

dfOut2 <- t(apply(df.sig/(df.insig+df.sig),1,function(x){x[COG_categories]-x["TotPhase"]}))

blues <- colorRampPalette(c("#91BFDB","#E0F3F8"))(5)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(8)

heat_plot <- pheatmap(dfOut2,
                      col = c(blues,reds),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)
  
# png("Chapter1_plots/COG_enrichment.png",height = 1080, width = 1920)
# heat_plot
# dev.off()


```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

COG_categories <- sort(unique(unlist(lapply(unique(Full.merged_rain$COG_category),
                                            function(x){strsplit(x,split = "")}))))

Full.merged_rain$COG_category[is.na(Full.merged_rain$COG_category)] <- "na"

COG_categories <- c(COG_categories,"na")

for(i in 1:length(phase.peaks)){
  if(i == 1){
    df.Fisher <- cbind.data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(COG_categories)),phase.peaks)
    
    names(df.Fisher) <- c(COG_categories,"phase.peaks")
    row.names(df.Fisher) <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  for(j in 1:length(COG_categories)){
    grep.Sig <- grep(COG_categories[j],df.temp$COG_category[df.temp$Sig == "Sig"])
    
    is.Sig.inGroup <- length(grep.Sig)
    is.Sig.NotInGroup <- sum(df.temp$Sig == "Sig")-length(grep.Sig)
    
    grep.insig <- grep(COG_categories[j],df.temp$COG_category[df.temp$Sig == "Insig"])
    
    not.Sig.inGroup <- length(grep.insig)
    not.Sig.NotInGroup <- sum(df.temp$Sig == "Insig")-length(grep.insig)
    
    d <- data.frame(is.Sig = c(is.Sig.inGroup,is.Sig.NotInGroup),
                    not.Sig = c(not.Sig.inGroup,not.Sig.NotInGroup))
    row.names(d) <- c("In.Group","NotIn.Group")
    
    df.Fisher[i,j] <- fisher.test(d,alternative = "t")$p.value
  }
}


blues <- colorRampPalette(c("#91BFDB","#E0F3F8"))(95)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(6)

heat_plot <- pheatmap(df.Fisher[,COG_categories],
                      col = c(rev(reds[-1]),blues),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

dfOut <- pivot_longer(df.Fisher,cols = all_of(COG_categories),names_to = "COG",values_to = "P.value")

q_val <- 0.05
abh_metric <- 1:nrow(dfOut)*(q_val/nrow(dfOut))

dfOut <- cbind.data.frame(dfOut[order(dfOut$P.value,decreasing = F),],abh_metric)

sig.list <- dfOut[dfOut$P.value<dfOut$abh_metric,]

for(i in 1:length(unique(sig.list$phase.peaks))){
  if(i == 1){
    df.siglist <- data.frame(matrix(NA,
                                    ncol = length(unique(sig.list$phase.peaks)),
                                    nrow = length(unique(sig.list$COG))))
    
    names(df.siglist) <- unique(sig.list$phase.peaks)
    row.names(df.siglist) <- unique(sig.list$COG)
  }
  
  df.temp <- sig.list[sig.list$phase.peaks == unique(sig.list$phase.peaks)[i],]
  
  for(j in 1:length(unique(sig.list$COG))){
    
    df.siglist[j,i] <- ifelse(any(df.temp$COG == unique(sig.list$COG)[j]),1,0)
    
  }
}

heat_plot <- pheatmap(t(df.siglist),
                      col = c("darkred","darkblue"),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

# png("Chapter1_plots/COG_Sig_enrichment1.png",height = 1000, width = 800)
# heat_plot
# dev.off()

```



```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

Full.merged_rain$K1_paths[is.na(Full.merged_rain$K1_paths)] <- "unannot"
Full.merged_rain$K1_paths[Full.merged_rain$K1_paths == ""] <- "no_path"

KEGG_paths <- sort(unique(Full.merged_rain$K1_paths))

for(i in 1:length(phase.peaks)){
  if(i == 1){
    df.sig <- data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(KEGG_paths)))
    df.insig <- data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(KEGG_paths)))
    
    names(df.sig) <- KEGG_paths
    df.sig$phase.peaks <- phase.peaks
    
    names(df.insig) <- KEGG_paths
    df.insig$phase.peaks <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  phase.rat <- sum(df.temp$Sig == "Sig")/nrow(df.temp)
  print(phase.rat)
  
  for(j in 1:length(KEGG_paths)){
    vec1 <- sum(df.temp$K1_paths[df.temp$Sig == "Sig"] == KEGG_paths[j])
    vec2 <- sum(df.temp$K1_paths[df.temp$Sig == "Insig"] == KEGG_paths[j])
    
    # df.sig[i,j] <- ifelse(vec1+vec2 == 0,0,vec1/(vec1+vec2))
    # df.insig[i,j] <- ifelse(vec1+vec2 == 0,0,vec2/(vec1+vec2))
    
    # df.sig[i,j] <- vec1
    # df.insig[i,j] <- vec2
    
    df.sig[i,j] <- ifelse(vec1+vec2 > 1/phase.rat,(vec1/(vec1+vec2))-phase.rat,0)
    
    # Adding weight to the significance ratio, by adding a value to the divisor, 
    # so that if a kegg path in that phase only has 1 observation, it will be equal 
    # to the average for the total of that phase.
    # Next step is to find top 10 paths for each phase.
    # df.sig[i,j] <- ifelse(vec1+vec2 > 0,(vec1/(vec1+vec2+(1/phase.rat))-phase.rat),0)
    df.insig[i,j] <- vec2+vec1
    
    
    
    # df.sig[i,j] <- ifelse(vec1+vec2 == 0,0,ifelse(vec1+vec2 == 1,0,vec1/(vec1+vec2)))
    # df.insig[i,j] <- ifelse(vec1+vec2 == 0,0,ifelse(vec1+vec2 == 1,0,vec2/(vec1+vec2)))
  }
  
  if(i == length(phase.peaks)){
    df.sig$Total <- apply(df.sig[,KEGG_paths],1,sum)
    df.insig$Total <- apply(df.insig[,KEGG_paths],1,sum)
    
    df.sig$Sig <- "Sig"
    df.insig$Sig <- "Insig"
    
    rm(list = c("df.temp"))
  }
}




rownames(df.sig) <- df.sig$phase.peaks

path_df <- data.frame("Paths" = KEGG_paths)
row.names(path_df) <- KEGG_paths

col_paths <- c(rep("white",317),"grey","black")
names(col_paths) <- c(KEGG_paths[!(KEGG_paths %in% c("no_path","unannot"))],"no_path","unannot")
col_paths <- list("Paths" = col_paths)

blues <- colorRampPalette(c("#91BFDB","#E0F3F8","#F7F7F7"))(8)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(20)

# blues <- colorRampPalette(c("#91BFDB","#E0F3F8"))(4)
# reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(7)

heat_plot <- pheatmap(df.sig[,KEGG_paths],
                      col = c(blues,reds),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      annotation_col = path_df,
                      annotation_colors = col_paths,
                      show_colnames = F,
                      annotation_legend = F,
                      fontsize = 15,
                      annotation_names_col = F)

# png("Chapter1_plots/KEGG_paths_enrichment.png",height = 1080, width = 1920)
# heat_plot
# dev.off()

top10 <- sort(apply(df.sig[1:12,KEGG_paths],2,max),decreasing = T)[1:10]
bottom10 <- sort(apply(df.sig[1:12,KEGG_paths],2,min),decreasing = F)[1:10]
```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

Full.merged_rain$K1_paths[is.na(Full.merged_rain$K1_paths)] <- "unannot"
Full.merged_rain$K1_paths[Full.merged_rain$K1_paths == ""] <- "no_path"

KEGG_paths <- sort(unique(Full.merged_rain$K1_paths))

for(i in 1:length(phase.peaks)){
  if(i == 1){
    df.Fisher <- cbind.data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(KEGG_paths)),phase.peaks)
    
    names(df.Fisher) <- c(KEGG_paths,"phase.peaks")
    row.names(df.Fisher) <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  for(j in 1:length(KEGG_paths)){
    is.Sig.inGroup <- sum(df.temp$K1_paths[df.temp$Sig == "Sig"] == KEGG_paths[j])
    is.Sig.NotInGroup <- sum(df.temp$K1_paths[df.temp$Sig == "Sig"] != KEGG_paths[j])
    not.Sig.inGroup <- sum(df.temp$K1_paths[df.temp$Sig == "Insig"] == KEGG_paths[j])
    not.Sig.NotInGroup <- sum(df.temp$K1_paths[df.temp$Sig == "Insig"] != KEGG_paths[j])
    
    d <- data.frame(is.Sig = c(is.Sig.inGroup,is.Sig.NotInGroup),
                    not.Sig = c(not.Sig.inGroup,not.Sig.NotInGroup))
    row.names(d) <- c("In.Group","NotIn.Group")
    
    df.Fisher[i,j] <- fisher.test(d,alternative = "g")$p.value
  }
}

path_df <- data.frame("Paths" = KEGG_paths)
row.names(path_df) <- KEGG_paths

col_paths <- c(rep("white",317),"grey","black")
names(col_paths) <- c(KEGG_paths[!(KEGG_paths %in% c("no_path","unannot"))],"no_path","unannot")
col_paths <- list("Paths" = col_paths)

blues <- colorRampPalette(c("#91BFDB","#E0F3F8","white"))(95)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(6)

heat_plot <- pheatmap(df.Fisher[,KEGG_paths],
                      col = c(rev(reds[-1]),blues),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      annotation_col = path_df,
                      annotation_colors = col_paths,
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

dfOut <- pivot_longer(df.Fisher,cols = all_of(KEGG_paths),names_to = "KEGG",values_to = "P.value")

q_val <- 0.05
abh_metric <- 1:nrow(dfOut)*(q_val/nrow(dfOut))

dfOut <- cbind.data.frame(dfOut[order(dfOut$P.value,decreasing = F),],abh_metric)

sig.list <- dfOut[dfOut$P.value<dfOut$abh_metric,]

for(i in 1:length(unique(sig.list$phase.peaks))){
  if(i == 1){
    df.siglist <- data.frame(matrix(NA,
                                    ncol = length(unique(sig.list$phase.peaks)),
                                    nrow = length(unique(sig.list$KEGG))))
    
    names(df.siglist) <- unique(sig.list$phase.peaks)
    row.names(df.siglist) <- unique(sig.list$KEGG)
  }
  
  df.temp <- sig.list[sig.list$phase.peaks == unique(sig.list$phase.peaks)[i],]
  
  for(j in 1:length(unique(sig.list$KEGG))){
    
    df.siglist[j,i] <- ifelse(any(df.temp$KEGG == unique(sig.list$KEGG)[j]),1,0)
    
  }
}

source("pathway_API.R")

vec <- unlist(lapply(row.names(df.siglist),function(x){ifelse(x %in% c("no_path","unannot"),x,pathway_API(x)$name)}))

row.names(df.siglist) <- vec

heat_plot <- pheatmap(df.siglist,
                      col = c("darkred","darkblue"),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

# png("Chapter1_plots/K1_pathsSigEnrichment.png",height = 1000, width = 800)
# heat_plot
# dev.off()

# for(i in 1:12){
#   vec <- names(sort(unlist(df.Fisher[i,KEGG_paths]))[1:5])
#   
#   if(i == 1){
#     top.vec <- vec
#   }else{
#     top.vec <- c(top.vec,vec[!(vec %in% top.vec)])
#   }
#   
# }


```


```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)
load("CSV_files/kegg_allPaths.RData",verbose = T)

filter <- !is.na(Full.merged_rain$KEGG_ko)

pathway_correlator <- function(kegg.ko){
  if(kegg.ko != "-"){
    
    kegg.vec <- unlist(strsplit(kegg.ko,split = ","))
    
    vec <- paste(unlist(lapply(kegg.vec,function(x){df.Paths$paths[df.Paths$ko == x]})),collapse = ",")
    
    return(vec)
  }else{
    return("-")
  }
}

Full.merged_rain$K1_paths[filter] <- unlist(lapply(Full.merged_rain$KEGG_ko[filter],pathway_correlator))

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

Full.merged_rain$K1_paths[is.na(Full.merged_rain$K1_paths)] <- "unannot"

KEGG.paths <- c(unique(unlist(lapply(df.Paths$paths,function(x){unlist(strsplit(x,split = ";"))}))),"unannot")

for(i in 1:length(phase.peaks)){
  if(i == 1){
    df.Fisher <- cbind.data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(KEGG_paths)),phase.peaks)
    
    names(df.Fisher) <- c(KEGG_paths,"phase.peaks")
    row.names(df.Fisher) <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  for(j in 1:length(KEGG.paths)){
    grep.Sig <- grep(KEGG.paths[j],df.temp$K1_paths[df.temp$Sig == "Sig"])
    
    is.Sig.inGroup <- length(grep.Sig)
    is.Sig.NotInGroup <- sum(df.temp$Sig == "Sig")-length(grep.Sig)
    
    grep.insig <- grep(KEGG.paths[j],df.temp$K1_paths[df.temp$Sig == "Insig"])
    
    not.Sig.inGroup <- length(grep.insig)
    not.Sig.NotInGroup <- sum(df.temp$Sig == "Insig")-length(grep.insig)
    
    d <- data.frame(is.Sig = c(is.Sig.inGroup,is.Sig.NotInGroup),
                    not.Sig = c(not.Sig.inGroup,not.Sig.NotInGroup))
    row.names(d) <- c("In.Group","NotIn.Group")
    
    df.Fisher[i,j] <- fisher.test(d,alternative = "t")$p.value
  }
}

path_df <- data.frame("Paths" = KEGG_paths)
row.names(path_df) <- KEGG_paths

col_paths <- c(rep("white",length(KEGG_paths)-2),"grey","black")
names(col_paths) <- c(KEGG_paths[!(KEGG_paths %in% c("-","unannot"))],"-","unannot")
col_paths <- list("Paths" = col_paths)

blues <- colorRampPalette(c("#91BFDB","#E0F3F8","white"))(95)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(6)

heat_plot <- pheatmap(df.Fisher[,KEGG_paths],
                      col = c(rev(reds[-1]),blues),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      annotation_col = path_df,
                      annotation_colors = col_paths,
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

dfOut <- pivot_longer(df.Fisher,cols = all_of(KEGG_paths),names_to = "KEGG",values_to = "P.value")

q_val <- 0.05
abh_metric <- 1:nrow(dfOut)*(q_val/nrow(dfOut))

dfOut <- cbind.data.frame(dfOut[order(dfOut$P.value,decreasing = F),],abh_metric)

sig.list <- dfOut[dfOut$P.value<dfOut$abh_metric,]

for(i in 1:length(unique(sig.list$phase.peaks))){
  if(i == 1){
    df.siglist <- data.frame(matrix(NA,
                                    ncol = length(unique(sig.list$phase.peaks)),
                                    nrow = length(unique(sig.list$KEGG))))
    
    names(df.siglist) <- unique(sig.list$phase.peaks)
    row.names(df.siglist) <- unique(sig.list$KEGG)
  }
  
  df.temp <- sig.list[sig.list$phase.peaks == unique(sig.list$phase.peaks)[i],]
  
  for(j in 1:length(unique(sig.list$KEGG))){
    
    df.siglist[j,i] <- ifelse(any(df.temp$KEGG == unique(sig.list$KEGG)[j]),1,0)
    
  }
}

# source("pathway_API.R")
# 
# vec <- unlist(lapply(row.names(df.siglist),function(x){ifelse(x %in% c("no_path","unannot"),x,pathway_API(x)$name)}))
# 
# row.names(df.siglist) <- vec

heat_plot <- pheatmap(df.siglist,
                      col = c("darkred","darkblue"),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

# for(i in 1:12){
#   vec <- names(sort(unlist(df.Fisher[i,KEGG_paths]))[1:5])
#   
#   if(i == 1){
#     top.vec <- vec
#   }else{
#     top.vec <- c(top.vec,vec[!(vec %in% top.vec)])
#   }
#   
# }


```


```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)
load("CSV_files/kegg_allPaths.RData",verbose = T)

Full.merged_rain$phase.peaks <- paste(Full.merged_rain$phase,Full.merged_rain$peak.shape,sep = "+")
phase.peaks <- factor(unique(Full.merged_rain$phase.peaks),
                      levels = c("Morning+6","Morning+12","Morning+18",
                                 "Afternoon+6","Afternoon+12","Afternoon+18",
                                 "Evening+6","Evening+12","Evening+18",
                                 "Night+6","Night+12","Night+18"))

filter <- is.na(Full.merged_rain$KEGG_ko)
Full.merged_rain$KEGG_ko[filter] <- "unannot"

KEGG.vec <- c(df.Paths$ko,"unannot")

for(i in 1:length(phase.peaks)){
  if(i == 1){
    Time1 <- Sys.time()
    df.Fisher <- cbind.data.frame(matrix(NA,nrow = length(phase.peaks),ncol = length(KEGG.vec)),phase.peaks)
    
    names(df.Fisher) <- c(KEGG.vec,"phase.peaks")
    row.names(df.Fisher) <- phase.peaks
  }
  
  filter <- Full.merged_rain$phase.peaks == phase.peaks[i]
  df.temp <- Full.merged_rain[filter,]
  
  for(j in 1:length(KEGG.vec)){
    grep.Sig <- grep(KEGG.vec[j],df.temp$KEGG_ko[df.temp$Sig == "Sig"])
    
    is.Sig.inGroup <- length(grep.Sig)
    is.Sig.NotInGroup <- sum(df.temp$Sig == "Sig")-length(grep.Sig)
    
    grep.insig <- grep(KEGG.vec[j],df.temp$KEGG_ko[df.temp$Sig == "Insig"])
    
    not.Sig.inGroup <- length(grep.insig)
    not.Sig.NotInGroup <- sum(df.temp$Sig == "Insig")-length(grep.insig)
    
    d <- data.frame(is.Sig = c(is.Sig.inGroup,is.Sig.NotInGroup),
                    not.Sig = c(not.Sig.inGroup,not.Sig.NotInGroup))
    row.names(d) <- c("In.Group","NotIn.Group")
    
    df.Fisher[i,j] <- fisher.test(d,alternative = "t")$p.value
  }
  print(paste(phase.peaks[i],"Finished.",round(difftime(Sys.time(),Time1,units = "hours"),2),"hours elapsed"))
}

path_df <- data.frame("Paths" = KEGG.vec)
row.names(path_df) <- KEGG.vec

col_paths <- c(rep("white",length(KEGG.vec)-2),"grey","black")
names(col_paths) <- c(KEGG.vec[!(KEGG.vec %in% c("-","unannot"))],"-","unannot")
col_paths <- list("Paths" = col_paths)

blues <- colorRampPalette(c("#91BFDB","#E0F3F8","white"))(95)
reds <- colorRampPalette(c("#FFFFFF","#D6604D","#67001F"))(6)

heat_plot <- pheatmap(df.Fisher[,KEGG.vec],
                      col = c(rev(reds[-1]),blues),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      annotation_col = path_df,
                      annotation_colors = col_paths,
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

dfOut <- pivot_longer(df.Fisher,cols = all_of(KEGG.vec),names_to = "KEGG",values_to = "P.value")

q_val <- 0.05
abh_metric <- 1:nrow(dfOut)*(q_val/nrow(dfOut))

dfOut <- cbind.data.frame(dfOut[order(dfOut$P.value,decreasing = F),],abh_metric)

# abh_metric <- 1:length(KEGG.vec)*(q_val/length(KEGG.vec))
# dfOut <- dfOut[order(dfOut$P.value,decreasing = F),]
# 
# for(i in 1:length(phase.peaks)){
#   dfOut$abh_metric[dfOut$phase.peaks == phase.peaks[i]] <- abh_metric
# }

sig.list <- dfOut[dfOut$P.value<dfOut$abh_metric,]

for(i in 1:length(unique(sig.list$phase.peaks))){
  if(i == 1){
    df.siglist <- data.frame(matrix(NA,
                                    ncol = length(unique(sig.list$phase.peaks)),
                                    nrow = length(unique(sig.list$KEGG))))
    
    names(df.siglist) <- unique(sig.list$phase.peaks)
    row.names(df.siglist) <- unique(sig.list$KEGG)
  }
  
  df.temp <- sig.list[sig.list$phase.peaks == unique(sig.list$phase.peaks)[i],]
  
  for(j in 1:length(unique(sig.list$KEGG))){
    
    df.siglist[j,i] <- ifelse(any(df.temp$KEGG == unique(sig.list$KEGG)[j]),1,0)
    
  }
}

source("pathway_API.R")

vec <- unlist(lapply(row.names(df.siglist),
                     function(x){ifelse(x %in% c("-","unannot"),x,pathway_API(x)$name)}))

row.names(df.siglist) <- vec

heat_plot <- pheatmap(df.siglist,
                      col = c("darkred","darkblue"),
                      cluster_rows = T,cluster_cols = T,
                      clustering_distance_cols = "euclidean",
                      clustering_distance_rows = "euclidean",
                      clustering_method = "ward.D",
                      show_colnames = T,
                      annotation_legend = F,
                      fontsize = 15)

# png("Chapter1_plots/KEGG_koSigEnrichment.png",height = 1500, width = 1400)
# heat_plot
# dev.off()

# for(i in 1:12){
#   vec <- names(sort(unlist(df.Fisher[i,KEGG.vec]))[1:5])
#   
#   if(i == 1){
#     top.vec <- vec
#   }else{
#     top.vec <- c(top.vec,vec[!(vec %in% top.vec)])
#   }
#   
# }

```

```{r}
load("CSV_files/FullMerged_rain.RData",verbose = T)

vec <- sample(nrow(Full.merged_rain),10000,replace = F)

# dfOut <- Full.merged_rain[vec,"KEGG1"]
# row.names(dfOut) <- Full.merged_rain$ID[vec]

kegga.vec <- kegga(Full.merged_rain[,"KEGG1"],geneid = Full.merged_rain$ID)
topKEGG(kegga.vec)

goana.vec <- goana(Full.merged_rain[,"GOs"],geneid = Full.merged_rain$ID)
```

```{r}

# https://rpubs.com/jrgonzalezISGlobal/enrichment

in_sig <- sum(Full.merged_rain$Sig == "Sig" & !is.na(Full.merged_rain$Domain))
in_insig <- sum(Full.merged_rain$Sig == "Insig" & !is.na(Full.merged_rain$Domain))

out_sig <- sum(Full.merged_rain$Sig == "Sig" & is.na(Full.merged_rain$Domain))
out_insig <- sum(Full.merged_rain$Sig == "Insig" & is.na(Full.merged_rain$Domain))

deTable <- matrix(c(in_sig,in_insig,out_sig,out_insig),
                  nrow = 2,
                  dimnames = list(DE=c("Sig","Insig"),
                                  GeneSet=c("in","out")))

deTable

fisher.test(deTable,alternative = "greater")

```



