---
title: "Time_series_clustering"
author: "Andreas Norlin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","patchwork","stringi",
                  "RColorBrewer","pheatmap")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

bioc.packages <- c("phyloseq","DESeq2")

if(!all(bioc.packages %in% installed.packages()[,"Package"])){
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(bioc.packages[!(bioc.packages %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)
library(RColorBrewer)
library(pheatmap)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

TPM <- TRUE

if(TPM == TRUE){
  load("CSV_files/Subsections.RData",verbose = TRUE)
}else{
  load("CSV_files/Subsections_numreads.RData",verbose = TRUE)
}

```



```{r, Data setup}

Input_data <- Bact.Sub
# Input_data <- rbind(Euk.Sub,Bact.Sub)

for(i in 1:nrow(Input_data)){
  if(i == 1){
    n_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  }
  m_KEGG <- length(unlist(strsplit(Input_data$KEGG_ko[i],",",fixed = TRUE)))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

Input_data <- separate(Input_data,col = KEGG_ko,into = KEGG_columns,
                     sep = ",", remove = FALSE, fill = "right", extra = "drop")

KO_paths_Bact <- read.csv("KO_pathway.csv")
KO_paths_Euk <- read.csv("KO_pathway_Euk.csv")

KO_paths <- rbind(KO_paths_Euk,
                  KO_paths_Bact[!(KO_paths_Bact$K1 %in% KO_paths_Euk$K1),])

Input_data$K1_paths <- unlist(lapply(Input_data$KEGG1,
                                     function(x){
                                       ifelse(x == "-","",KO_paths$ko[KO_paths$K1 == x])}))

# Input_data <- Input_data[!is.na(Input_data$Class),]
Input_data$Domain_K1 <- paste(Input_data$Domain,Input_data$KEGG1,sep = "_")

source("summary_count.R")

day.vec <- paste(meta.data$SampleID,"_quant",sep = "")

df.count <- summary_count(Input_data,Col_vec = day.vec,Col_filter = "Domain_K1")

names(df.count) <- unlist(lapply(names(df.count),
                                 function(x){unlist(strsplit(x,
                                                             split = "_",
                                                             fixed = TRUE))[1]}))

df_meta <- meta.data[,c("SampleID","SampleName","AssemblyGroup","Day.num","ToD")] %>%
  mutate(ToD = factor(ToD,levels = c("morning","afternoon","evening","night")))


# Optional extra step to average the replicates of each day ####
AvgDays <- T

if(AvgDays == TRUE){
  # Input_data <- Bact.Sub
  
  Input_data <- df.count
  
  vec_assembly <- unique(meta.data$AssemblyGroup)
  
  for(i in 1:length(vec_assembly)){
    if(i == 1){
  
      df_means <- row.names(Input_data)
    }
  
    df_temp <- Input_data[,meta.data$SampleID[meta.data$AssemblyGroup == vec_assembly[i]]]
  
    meta_temp <- df_meta %>%
      distinct(AssemblyGroup,.keep_all = TRUE) %>%
      filter(AssemblyGroup == vec_assembly[i])
  
    vec <- rowMeans(df_temp)
    # vec <- rowSums(df_temp)
    df_means <- cbind.data.frame(df_means,vec)
  
    names(df_means)[i+1] <- vec_assembly[i]
  }
  
  # creating factors for the ToD in order to analyse the time points chronologically
  df_meta <- df_meta %>%
    distinct(AssemblyGroup,.keep_all = TRUE)
  
  df.count <- df_means[,-1]
  rm(list = c("df_means"))
}

```

```{r}

Order_vec <- c("Day1_morning","Day1_afternoon",
               "Day1_evening","Day1_night",
               "Day2_morning","Day2_afternoon",
               "Day2_evening","Day2_night")

time_points <- (0:7)*6

# Detrending the dataset, by subtracting the linear model values from the data
dfOut <- t(apply(df.count[,Order_vec],1,function(x){x - lm(unlist(x)~time_points)$fitted.values}))

# Scaling data using z-score transformation
dfOut <- t(apply(dfOut,1,function(x){(x-mean(x))/sd(x)}))
# dfOut <- df.count

dfOut <- cbind.data.frame(dfOut,"Gene" = row.names(dfOut))[-3,]

# dfOut <- pivot_longer(dfOut,cols = 1:8,names_to = "ToD",values_to = "TPM") %>% 
#   mutate(ToD = factor(ToD,
#                       levels = Order_vec))

random_select <- sample(nrow(dfOut))

dfOut_long <- pivot_longer(dfOut[random_select,],cols = 1:8,names_to = "ToD",values_to = "TPM")
dfOut_long$ToD <- unlist(lapply(dfOut_long$ToD,function(x){(1:8)[Order_vec == x]}))

ggplot(dfOut_long)+
  geom_line(aes(x = ToD,
                y = TPM,
                group = Gene))+
  scale_x_continuous(breaks = 1:8,
                     labels = Order_vec)+
  theme(legend.position = "none")
  
```

```{r}

rainresult <- rain(t(dfOut[,-9]),
                   period = 24,
                   deltat = 6,
                   verbose = T)

rainresult

best <- order(rainresult$pVal,decreasing = F)[1:10]
require('lattice')
xyplot(as.matrix(dfOut[best, -9])
       ~rep(0:7 * 6, each = 10) |rownames(dfOut)[best],
       scales = list(y = list(relation = 'free')),
       layout = c(2, 5), type = 'b', pch = 16, xlab = 'time',
       ylab = 'expression value', cex.lab = 1)

# Explorations of the rain output:
unique(rainresult$phase)
unique(rainresult$peak.shape)
sum(rainresult$pVal < 0.01)
sum(rainresult$pVal < 0.05)
rainresult[(rainresult$pVal < 0.01),]
unique(rainresult$phase[(rainresult$pVal < 0.01)])
unique(paste(rainresult$phase,rainresult$peak.shape,sep = "_"))
```

