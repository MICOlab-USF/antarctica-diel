---
title: "Clustered_heatmap"
author: "Andreas Norlin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

rm(list = ls())

package.list <- c("dplyr","tidyverse","ggplot2",
                  "lemon","vegan","Rmisc",
                  "lubridate","patchwork","stringi",
                  "RColorBrewer","pheatmap")

if(!all(package.list %in% installed.packages()[,"Package"])){
  install.packages(package.list[!(package.list %in% installed.packages()[,"Package"])])
}

bioc.packages <- c("phyloseq","DESeq2")

if(!all(bioc.packages %in% installed.packages()[,"Package"])){
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(bioc.packages[!(bioc.packages %in% installed.packages()[,"Package"])])
}

library(dplyr)
library(tidyverse)
library(ggplot2)
library(lemon)
library(vegan)
library(Rmisc)
library(lubridate)
library(RColorBrewer)

library(phyloseq)
library(patchwork)
library(DESeq2)
library(stringi)

library(pheatmap)

load("CSV_files/Subsections.RData",verbose = TRUE)
```

```{r}

# Setting up and splitting kegg columns ####

for(i in 1:nrow(Euk.Sub)){
  if(i == 1){
    n_KEGG <- length(unlist(strsplit(Euk.Sub$KEGG_ko[i],",")))
  }
  m_KEGG <- length(unlist(strsplit(Euk.Sub$KEGG_ko[i],",")))
  
  if(m_KEGG > n_KEGG){
    n_KEGG <- m_KEGG
  }
}

KEGG_columns <- paste("KEGG",1:n_KEGG,sep = "")

Euk.Sub <- separate(Euk.Sub,col = KEGG_ko,into = KEGG_columns,
                      sep = ",", remove = FALSE, fill = "right", extra = "drop")

# Kegg Path lookup####

Euk_KO_paths <- read.csv("KO_pathway_Euk.csv")

for(i in 1:nrow(Euk.Sub)){
  if(i == 1){
    Ko_path <- rep(NA,nrow(Euk.Sub))
  }

  vec <- Euk.Sub$KEGG1[i]

  vec_paths <- Euk_KO_paths$ko[Euk_KO_paths$K1 == vec]

  if(vec == "-"){
    vec_paths <- ""
  }

  if(vec_paths == ""){
    for(j in 2:length(KEGG_columns)){
      if(j == 2){
        stop_vec <- TRUE
      }

      if(stop_vec){
        vec <- Euk.Sub[i,KEGG_columns[j]]

        if(is.na(vec)){
          stop_vec <- FALSE
          vec_paths <- ""
        } else {
          vec_paths <- Euk_KO_paths$ko[Euk_KO_paths$K1 == vec]
        }

        if(vec_paths != ""){
          stop_vec <- FALSE
        }
      }
    }


  }
  if(vec_paths == ""){
    vec_paths <- "Unclassified"
  }

  Ko_path[i] <- vec_paths
}

Euk.Sub$K1_path <- Ko_path
```

```{r test}
AssemblyGroups <- unique(meta.data$AssemblyGroup)

AssemblyGroup.means <- matrix(nrow = nrow(Euk.Sub),ncol = length(AssemblyGroups))

for(i in 1:length(AssemblyGroups)){
  vec.cols <- paste0(meta.data$SampleID[meta.data$AssemblyGroup == AssemblyGroups[i]],"_quant")
  filter <- names(Euk.Sub) %in% vec.cols
  AssemblyGroup.means[,i] <- apply(Euk.Sub[,filter],1,mean)
}

rownames(AssemblyGroup.means) <- Euk.Sub$SequenceID
colnames(AssemblyGroup.means) <- AssemblyGroups

df.merged <- cbind.data.frame(AssemblyGroup.means,
                              "Family" = Euk.Sub$Family,
                              "K1_path" = Euk.Sub$K1_path)

# Euk.Sub$Family <- unlist(lapply(Euk.Sub$Family,function(x){unlist(strsplit(x,split = "_"))[1]}))
# 
# sort(unique(Euk.Sub$Family))

AsGroup <- AssemblyGroups[8]
filter <- names(df.merged) %in% c(AsGroup,"Family","K1_path")

df.merged2 <- df.merged[!is.na(df.merged$Family),filter]

kegg.paths <- unique(df.merged2$K1_path)
# kegg.paths2 <- rownames(df.count)

source("pathway_API.R")

Euk.Families <- unique(df.merged2$Family)

n <- length(kegg.paths)
m <- length(Euk.Families)

#------------------------------------------------------------------------------
for(i in 1:n){ #Looping through the paths to count the occurrences.
  
  kegg.filter <- df.merged2$K1_path == kegg.paths[i]
  df.temp <- df.merged2[kegg.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     colnames(df.count) <- Euk.Families
     rownames(df.count) <- kegg.paths2 #unlist(lapply(kegg.paths,function(x){if(x != "Unclassified"){pathway_API(x)$name}else{"Unclassified"}}))
     
     df.count2 <- data.frame(matrix(ncol = m, nrow = n))
     colnames(df.count2) <- Euk.Families
     rownames(df.count2) <- kegg.paths
     
     
   }
    
    Family.filter <- df.temp$Family == Euk.Families[j]
    
    vec <- sum(df.temp[Family.filter,1])
    
    df.count[i,j] <- ifelse(vec != 0,log(vec),-6)
    df.count2[i,j] <- vec
    
  }
}

vec_rows <- order(apply(df.count2,1,mean),decreasing = TRUE)
vec_cols <- order(apply(df.count2,2,mean),decreasing = TRUE)

heat_plot <- pheatmap(t(df.count[vec_rows,vec_cols]),
                      cluster_rows = T, cluster_cols = T, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      main = AsGroup,
                      fontsize_row = 7,
                      fontsize_col = 5)

# Save it -----------------------------------------------------------
name_vec <- paste0("Heatmaps/",AsGroup,".pdf")

pdf(name_vec, height = 25, width = 20)
heat_plot
dev.off()


```


```{r test}
## Get heatmap ===================================================
pheatmap(data)

# Clustering ===================================================
pheatmap(data, 
         cluster_rows = T, cluster_cols = T, # set to FALSE if you want to remove the dendograms
         clustering_distance_cols = 'euclidean',
         clustering_distance_rows = 'euclidean',
         clustering_method = 'ward.D')

```

```{r test}
AssemblyGroups <- unique(meta.data$AssemblyGroup)

AssemblyGroup.means <- matrix(nrow = nrow(Euk.Sub),ncol = length(AssemblyGroups))

for(i in 1:length(AssemblyGroups)){
  vec.cols <- paste0(meta.data$SampleID[meta.data$AssemblyGroup == AssemblyGroups[i]],"_quant")
  filter <- names(Euk.Sub) %in% vec.cols
  AssemblyGroup.means[,i] <- apply(Euk.Sub[,filter],1,mean)
}

rownames(AssemblyGroup.means) <- Euk.Sub$SequenceID
colnames(AssemblyGroup.means) <- AssemblyGroups

df.merged <- cbind.data.frame(AssemblyGroup.means,
                              "Family" = Euk.Sub$Family,
                              "K1_path" = Euk.Sub$K1_path)

df.merged <- df.merged[!is.na(df.merged$Family),]

kegg.paths <- unique(df.merged$K1_path)
Euk.Families <- unique(df.merged$Family)

n <- length(Euk.Families)
m <- length(AssemblyGroups)

#------------------------------------------------------------------------------
for(i in 1:n){ #Looping through the paths to count the occurrences.
  
  Family.filter <- df.merged$Family == Euk.Families[i]
  df.temp <- df.merged[Family.filter,]
  
  for(j in 1:m){ #Looping through the sampling time points.
    
   if(i == 1 & j == 1){ #Sets up an empty data.frame to input the data
     
     df.count <- data.frame(matrix(ncol = m, nrow = n))
     colnames(df.count) <- AssemblyGroups
     rownames(df.count) <- Euk.Families
     
     
   }
    
    Day.filter <- names(df.temp) == AssemblyGroups[j]
    
    vec <- sum(df.temp[,Day.filter])
    
    df.count[i,j] <- ifelse(vec != 0,log(vec),0)
    # df.count[i,j] <- sum(df.temp[,day.vec[j]])
    
  }
}

pheatmap(t(df.count[rownames(df.count) != "Unclassified",]),
         cluster_rows = T, cluster_cols = T, # set to FALSE if you want to remove the dendograms
         clustering_distance_cols = 'euclidean',
         clustering_distance_rows = 'euclidean',
         clustering_method = 'ward.D')



```





























